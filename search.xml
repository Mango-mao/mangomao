<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[面向对象（4）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%885%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>面向对象——原型链、作用域、函数（都是以函数为中心）</p>
<h4 id="一、函数的四种调用模式"><a href="#一、函数的四种调用模式" class="headerlink" title="一、函数的四种调用模式"></a>一、函数的四种调用模式</h4><blockquote>
<ul>
<li><p>函数有下列调用模式</p>
<ul>
<li>函数调用模式</li>
<li>方法模式</li>
<li>构造器模式</li>
<li>上下文模式</li>
</ul>
</li>
<li><p>函数的定义方式</p>
<ul>
<li>声明式</li>
<li>表达式式</li>
<li>Function</li>
</ul>
</li>
<li><p>单独独立调用的就是函数</p>
<ul>
<li>函数名( 参数 )</li>
<li>表示全局对象</li>
<li>任何自调用函数都是函数模式</li>
</ul>
</li>
<li><p>方法调用 模式   method</p>
<ul>
<li>区分<ul>
<li>方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.</li>
</ul>
</li>
<li>对象.方法( 参数 )<ul>
<li>this 表示引导方法的对象</li>
</ul>
</li>
</ul>
</li>
<li>方法调用一定要有宿主对象，方法一定是某个对象的方法，对象可以是任何对象（非基本数据类型）</li>
<li>函数也是对象，也可以调用方法</li>
<li>方法调用, 常常称为静态方法<pre><code>* o.func();
* fn.func();
* arr.func();
* arr[n].func();
</code></pre></li>
</ul>
</blockquote>
<h4 id="二、错题"><a href="#二、错题" class="headerlink" title="二、错题"></a>二、错题</h4><pre><code>var length = 10;
function fn() {
    console.log( this.length );
}
var obj = {
    length: 5,
    method: function ( fn ) {
        fn();
        arguments[ 0 ]();
    }
};
obj.method( fn, 1 );
</code></pre><h4 id="三、构造器模式-构造函数模式-构造方法模式"><a href="#三、构造器模式-构造函数模式-构造方法模式" class="headerlink" title="三、构造器模式(构造函数模式, 构造方法模式)"></a>三、构造器模式(构造函数模式, 构造方法模式)</h4><blockquote>
<ul>
<li>constructor</li>
<li>区分<ul>
<li>使用 new 关键字引导</li>
</ul>
</li>
<li>执行步骤<ul>
<li>var p = new Person();</li>
<li>new 是一个运算符, 专门用来申请创建对象(本质上就是申请一段内存), 创建出来的对象传递给构造函数的 this,利用构造函数对其初始化<br>new以后就创建了对象类似于{}，但是原型结构不同，其类型由构造函数决定</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>   function Person () {
       this.name = &apos;jim&apos;;
       this.age = 19;
       this.gender = &apos;male&apos;;
   }

* 理解:当new了一个新对象之后,this就等于这个新创建的对象,this.age等成员就相当于给新创建的对象加成员，完成赋值，依赖的原理是对象动态添加成员的特性(new 的过程会去创建一个空的对象，将这个新创建的空对象赋值给Person函数中的this，此时我们就可以通过this来访问这个新对象了，开始执行Person函数内部的代码；this现在是新创建的对象，所以我们给新创建的对象添加name属性为jack，age属性为20；如果Person函数中没有写return语句，那么默认返回新创建的对象this）
</code></pre><p>交给构造函数初始化</p>
<ul>
<li>var one={}；和构造器的原型不能</li>
<li><p>返回值</p>
<ul>
<li>如果不写 return 语句, 那么 构造函数 默认返回 this</li>
<li>如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. </li>
<li><p>如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this</p>
</li>
<li><p>如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的<br>function Person(){return;this.age=18}</p>
</li>
</ul>
</li>
</ul>
<h4 id="四、关于构造函数结合性的一个小结"><a href="#四、关于构造函数结合性的一个小结" class="headerlink" title="四、关于构造函数结合性的一个小结"></a>四、关于构造函数结合性的一个小结</h4><blockquote>
<ul>
<li>如果构造函数没有参数, 可以省略 圆括号<ul>
<li>var p = new Person;</li>
</ul>
</li>
<li>如果希望创建对象并直接调用其方法<ul>
<li>( new Person () ).sayHello()</li>
<li>可以省略调整结合性的圆括号</li>
<li>new Person().sayHello()</li>
<li>如果想要省略构造函数的圆括号, 就必须添加结合性的圆括号</li>
<li>(new Person).sayHello()</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="五、上下文调用模式"><a href="#五、上下文调用模式" class="headerlink" title="五、上下文调用模式"></a>五、上下文调用模式</h4><blockquote>
<ul>
<li>就是 环境调用模式 =&gt; 在不同环境下的不同调用模式<br>*简单说就是统一一种格式, 可以实现 函数模式与方法模式</li>
</ul>
</blockquote>
<ul>
<li>语法(区分)<ul>
<li>call 形式<ul>
<li>函数名.call( … )</li>
</ul>
</li>
<li>apply 形式<ul>
<li>函数名.apply( … )</li>
</ul>
</li>
<li>这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li><p>存在上下文调用的目的就是为了实现借用方法</p>
<p> function foo () {</p>
<pre><code>console.log( this );
</code></pre><p> }<br> var o = { name: ‘jim’ };<br> foo();<br> o.func = foo;<br> o.func();<br> // 如果需要让函数以函数的形式调用, 可以使用<br> foo.apply( null ) 或 foo.apply()<br> // 如果希望他是方法调用模式, 注意需要提供一个宿主对象<br> foo.apply( o )该方式调用，不会污染宿主对象，不必要宿主对象，必须包含该方法</p>
</li>
</ul>
</li>
<li><p>带有参数的函数如何实现上下文调用</p>
<pre><code>function foo ( num1, num2 ) {
    console.log( this );
    return num1 + num2;
} 
// 函数调用模式
var res1 = foo( 123, 567 );
// 方法调用
var o = { name: &apos;jim&apos; };
o.func = foo;
var res2 = o.func( 123, 567 );
</code></pre><ul>
<li>使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象</li>
<li>如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个</li>
<li><p>数组参数, 将函数的参数依次放在数组中. </p>
<p> 例如: 函数模式        foo( 123, 567 );</p>
<pre><code>apply         foo.apply( null, [ 123, 567 ] )
</code></pre></li>
<li><p>如果有一个函数调用: func( ‘张三’, 19, ‘男’ ), 将其修改成 apply 模式<br> func.apply( null, [ ‘张三’, 19, ‘男’] )</p>
<p> 方法模式:           o.func( 123, 567 )<br> apply               foo.apply( o, [ 123, 567 ] )</p>
</li>
<li><p>函数中的this到底是什么</p>
</li>
<li>函数中this是由调用函数的模式来决定的<ul>
<li>函数调用模式=》this：window</li>
<li>方法调用模式=》this：调用方法的对象</li>
<li>构造器调用模式=》this：new出来的那个对象</li>
<li>上下文调用模式 this：apply或call方法的第一个参数，如果是null，this就是window，如果第一个参数是对象，this就是这个对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="六、call-调用"><a href="#六、call-调用" class="headerlink" title="六、call 调用"></a>六、call 调用</h4><ul>
<li>在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂</li>
<li><p>所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组<br>赋值赋的是函数体，不包含宿主对象</p>
<p> foo( 123, 567 );<br> foo.apply( null, [ 123, 567 ] );<br> foo.call( null, 123, 567 );</p>
</li>
</ul>
<h4 id="七、借用构造方法实现继承"><a href="#七、借用构造方法实现继承" class="headerlink" title="七、借用构造方法实现继承"></a>七、借用构造方法实现继承</h4><pre><code>function Person ( name, age, gender ) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
function Student ( name, age, gender, course ) {
    Person.call( this, name, age, gender );
    this.course = course;
}
var p = new Student ( &apos;jim&apos;, 19, &apos;male&apos;, &apos;前端&apos; );
</code></pre><ol>
<li><p>函数的 bind 方法</p>
<ul>
<li><p>bind 就是 绑定</p>
<ul>
<li>就是让函数绑定对象的一种用法</li>
<li>函数本身就是可以调用, 但是其如果想要作为方法调用, 就必须传入宿主对象, 并且使用 call 或 apply 形式</li>
<li>但是 bind 使得我的函数可以与某一个对象绑定起来, 那么在调用函数的时候, 就好像是该对象在调用方法</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>函数.bind( 对象 )   </li>
<li>返回一个函数 foo</li>
<li>那么调用 返回的函数 foo, 就好像 对象在调用 该方法一样</li>
</ul>
</li>
</ul>
</li>
<li><p>Object.prototype 的成员<br>1) constructor<br>2) hasOwnProperty 判断该属性是否为自己提供<br>3) propertyIsEnumerable 判断属性是否可以枚举<br>4) isPrototypeOf    判断是否为原型对象<br>5) toString, toLocaleString, valueOf</p>
</li>
<li><p>包装对象<br>字符串 string 是基本类型, 理论上讲不应该包含方法<br>charAt, substr, slice, …</p>
<p>在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型</p>
<p>Number<br>String<br>Boolean</p>
<p>在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候<br>自动的将基本类型转换成对象类型.</p>
<p>“abc”.charAt( 1 )</p>
<p>“abc” -&gt; new String( “abc” )<br>s.charAt( 1 ) 返回结果<br>s 就被销毁</p>
<p>当   基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法.<br>方法执行结束后, 这个对象就被立刻回收</p>
<p>在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字<br>就会自动转换成对应的包装类型</p>
</li>
<li><p>getter 与 setter 的语法糖</p>
<p>语法糖: 为了方便开发而给出的语法结构</p>
<p>var o = (function () {</p>
<pre><code>var num = 123;
return {
    get_num: function () {
        return num;
    },
    set_num: function ( v ) {
        num = v;
    }
};
</code></pre><p>})();</p>
<p>// 获得数据<br>o.get_num();            =&gt; o.num 形式</p>
<p>// 设置<br>o.set_num( 456 );       =&gt; o.num = 456 形式</p>
<p>var o = (function () {</p>
<pre><code>var num = 123;
return {

    // get 名字 () { 逻辑体 }
    get num () {
        return num;
    }

    // set 名字 ( v ) { 逻辑体 }
    set num ( v ) {
        num = v;
    }
};
</code></pre><p>})();</p>
</li>
<li><p>ES5 中引入的部分数组方法<br>1&gt; forEach<br>2&gt; map<br>3&gt; filter<br>4&gt; some<br>5&gt; every<br>6&gt; indexOf<br>7&gt; lastIndexOf</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（4）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%884%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><ul>
<li>闭包的概念<ul>
<li>闭包就是封闭，包裹的意思，在js中就是指函数</li>
<li>函数内的空间就是一个封闭的包裹的范围</li>
<li>因此闭包就是函数所构成的一个外部无法直接访问的区域</li>
</ul>
</li>
<li>在js中，什么是闭包<ul>
<li>函数内有个内存空间，函数运行要分配内存空间</li>
<li>在js中函数是一个具有变量作用域隔离特性的一个内存结构，即为一个闭包。正确的说法，定义一个函数，可以构成一个闭包</li>
</ul>
</li>
<li>闭包的本质<ul>
<li>利用作用域访问规则的不可逆性，构成一个单向的空间</li>
</ul>
</li>
<li>要解决的问题<ul>
<li>在js中闭包要解决的问题就是间接的访问到这个被隔离的数据（不能直接访问，就间接访问）</li>
<li>函数运行内存模型</li>
</ul>
</li>
</ul>
<h4 id="二、在外部访问num中的数据"><a href="#二、在外部访问num中的数据" class="headerlink" title="二、在外部访问num中的数据"></a>二、在外部访问num中的数据</h4><blockquote>
<ul>
<li>函数是基本的对象类型，在js中与普通对的对象具有一样的意义<ul>
<li>函数可以作为变量一样赋值</li>
<li>作为参数一样传递</li>
<li>作为返回值使用</li>
</ul>
</li>
<li>闭包的间接访问<ul>
<li>使用return数据不能直接访问原来的数据，那么可以考虑利用函数的返回访问原始数据</li>
<li>foo只调用一次，就可以创建一个原始数据，但是返回的函数可以重复调用，每调用一次就是在获取闭包中的数据的值</li>
</ul>
</li>
<li>闭包代码的基本结构</li>
</ul>
</blockquote>
<pre><code>function foo(){
   var num=123;
   return function(){
       return num;
    }
 }
</code></pre><blockquote>
<ul>
<li>如何返回闭包中的数据<ul>
<li>返回单个数据：只要返回一个函数（这个函数返回我们需要的那个数据），就可以了</li>
<li>返回多个数据：需要返回一个对象（这个对象拥有多个方法，每一个方法返回一个需要的数据）来返回多个数据</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="三、利用闭包——实现私有数据"><a href="#三、利用闭包——实现私有数据" class="headerlink" title="三、利用闭包——实现私有数据"></a>三、利用闭包——实现私有数据</h4><blockquote>
<ul>
<li>函数允许返回一个对象，那么该对象可以提供数据访问方法，但是数据存储在闭包中，达到私有的目的</li>
</ul>
</blockquote>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><ul>
<li>构造函数里面的return 有什么用<ul>
<li>构造函数一般是不用写return的，不写return默认返回new出来的哪一个新对象</li>
<li>现在就是在构造函数里写了return，就不会返回new出来的那一个新对象了，而是返回return后面的对象（不包含基本类型的内容，如果return后面的内容是基本类型的数据，无视该return，直接返回new出来的那一个对象）</li>
</ul>
</li>
</ul>
<pre><code>function Person(name,age,gender){
     var newObj=this;
     newObj.name=name;
     newObj.age=age;
     newObj.gender=gender;
     return{
         get_name:function(){
             console.log(this);
             return this.name;

         },
         set_name:function(val){
             if(typeof val===&apos;string&apos; &amp;&amp; val.length&lt;=5){
                 newObj.name=val;
             }
         },
         get_age:function(){
             return newObj.age;
         },
         set_age:function(val){
             if(typeof val===&apos;number&apos; &amp;&amp; val&gt;=0){
                 newObj.age=val;
             }
         },
         get_gender:function(){
             return newObj.gender;
         },
         set_gender:function(val){
             if(val===&apos;男&apos;||val===&apos;女&apos;){
                 newObj.gender=val;
             }
         }
     } }
</code></pre><h4 id="四、闭包的核心"><a href="#四、闭包的核心" class="headerlink" title="四、闭包的核心"></a>四、闭包的核心</h4><blockquote>
<ul>
<li>闭包实现各种特性，其根本的核心内容只有两个<ul>
<li>带有私有数据的函数</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>function foo（）{
     var num=123；
     return function（）{
        //可以访问num
    }
}
var func=foo();
//称func是一个带有私有数据的函数
//称func带有缓存
</code></pre><blockquote>
<ul>
<li>带有私有数据的对象</li>
</ul>
</blockquote>
<h4 id="五、闭包的应用"><a href="#五、闭包的应用" class="headerlink" title="五、闭包的应用"></a>五、闭包的应用</h4><blockquote>
<ul>
<li>沙箱模式<ul>
<li>沙箱就是一个隔离的执行环境<ul>
<li>在js中什么情况需要使用沙箱</li>
<li>function Person（）{}</li>
<li>定义变量越多，出现冲突的可能性越大</li>
</ul>
</li>
<li>就是一个自调用的函数，将数据放到自调用的函数中，此时就不会发生全局作用域的污染了，而且我们还会在自调用的函数中返回一个接口</li>
</ul>
</li>
<li>事件追加——模拟onload事件的追加与移除<ul>
<li>注意——删除以后 arr.length 就发生变化了</li>
<li>console.log( {} == {} );  比较他们的引用，每次解析的都不同</li>
<li>setInterval(function(){},100);其实是创建了很多次函数</li>
<li>建议 function f(){};setInterval(f,100);</li>
</ul>
</li>
<li>cache缓存对象——搭建基本结构<ul>
<li>闭包的缺点：数据会一直占据内存</li>
<li>cache对象，可以使用cache[key]=value存储数据，cache[key]获得数据，当cache里面的数据达到1024条，将最早放进去的数据溢出</li>
<li>cache={}可以存取数据，但是不能限定数据的长度<br>如果需要限定数据，就是在加入数据的时候判断，是否已超过尺寸，如果是，则移除，如果不是，则什么也不做</li>
<li>将cache做成函数，添加数据使用 cache(key,value)，而且函数本身也是对象<br>function cache(key,value){<br>//可以在这里加上限定长度的代码<br>cache[key]=value;<br>}<br>由于需要记录键的数量，并且需要记录添加数据的先后顺序，所以首先考虑有序的数组，因此需要让cache函数带有缓存功能（这个数组就是）</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（3）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、函数声明与变量声明在一起的时候的注意点"><a href="#一、函数声明与变量声明在一起的时候的注意点" class="headerlink" title="一、函数声明与变量声明在一起的时候的注意点"></a>一、函数声明与变量声明在一起的时候的注意点</h4><blockquote>
<ul>
<li>函数的声明实际上包含两部分<ul>
<li>第一部分 告诉解释器 这个名字已经可以使用 （函数名，标识符）</li>
<li>第二部分 告诉解释器，这个名字代表着一个函数（变量里存储着函数的引用）</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>function func(){}
console.log(&apos;func&apos; in window)//当前执行环境中已经存在了func标识符
console.log(type func)//function
func=123;
console.log(func)//123
console.log(typeof func)
//获得对象的类型
console.log(Object.prototype.toString.call(func))
</code></pre><blockquote>
<ul>
<li><p>当函数声明与变量声明冲突的时候，只看谁先有数据<br>函数的声明比变量的声明意义多一层，声明变量，是告诉解释器当前环境可以使用该名字，而声明函数，是告诉解释器，除了可以使用该名字，该名字还表示一个函数体</p>
<ul>
<li>先var num;后function num…<ul>
<li>首先告知解释器有名字 num了</li>
<li>后面是函数声明，由于已经有num名字可以使用了，所以就不再告诉解释器可以使用num，而是直接将num与函数结合在一起</li>
</ul>
</li>
<li>先function num 后var num<ul>
<li>一开始已经有num了，而且是函数，其实就是告诉解释器有个num可以用了，所以后面的num；属于重复声明，直接无效</li>
</ul>
</li>
</ul>
</li>
<li><p>一个在新版本的浏览器中的特性</p>
</li>
</ul>
</blockquote>
<pre><code> if(true){
      function foo(){
          console.log(true);}
}else{
     function foo(){
          console.log(false);}
}
foo();
</code></pre><p>在早期的浏览器中（2015年）所有的浏览器（除了火狐）都是将其解释为声明，打印的是false，现在的浏览器最后的运行结果是true，表示if起到了作用</p>
<pre><code> if(true){
      function foo1(){
          console.log(true);}
}else{
     function foo2(){
          console.log(false);}
}

foo2();//error:foo2 is not function 已定义，但是函数未被指向
//虽然这两个函数不是声明，但是也不能解释成函数表达式
//如果是函数表达式foo1与foo2只能在函数内部使用
//因此不推荐把函数声明写在代码块中（if语句，循环，{}里面）
//有可能出现这样的问题：声明成功了一半（会在当前作用域中添加这个名字，代表可以使用。但是不会给他添加一层函数的含义）
</code></pre><h4 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h4><blockquote>
<ul>
<li>词法作用域</li>
<li>作用域：就是变量可以使用到不能使用的范围</li>
<li>块级作用域：<ul>
<li>块：代码块，即{}</li>
<li>变量的使用从定义开始，到其所在的块级作用域结束</li>
<li>代表语言：C，C++，C#，Java</li>
</ul>
</li>
<li>js词法作用域<ul>
<li>词法：就是定义，书写代码的规则</li>
<li>所以，所谓的词法作用域，就是在书写代码的时候，根据书写代码的结构就可以确定数据的访问范围的作用域</li>
<li>js不受块的影响，即使在块中定义声明变量，在块的外面依旧可以使用</li>
<li>所谓的js的词法作用域，就是根据预解析规则定义变量的使用范围，全部代码中只有函数可以限定范围，其它均不能限定访问范围。在函数内部是一个独立的作用范围结构</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="三、JS词法作用域的细节"><a href="#三、JS词法作用域的细节" class="headerlink" title="三、JS词法作用域的细节"></a>三、JS词法作用域的细节</h4><blockquote>
<ul>
<li>在没有函数的情况下，所有的变量的访问规则依据预解析规则</li>
<li>只有函数可以限定作用域，其它的不行</li>
<li>在函数内部是一个独立的完整的作用域结构</li>
<li>在函数内部，允许再定义函数，同时两个层次的函数都是作用域的独立体</li>
<li>允许在函数内，访问函数外的变量，前提是函数内没有该变量的声明<ul>
<li>优先访问当前作用域的数据</li>
</ul>
</li>
<li>结论<ul>
<li>词法作用域就是描述变量的访问范围：<ul>
<li>在代码中只有函数可以限定作用范围，允许函数访问外部的变量，反之不允许</li>
<li>在函数内优先访问内部声明的变量，如果没有才会访问外部的</li>
<li>所有变量的访问规则，按照预解析规则来访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="四、函数的参数"><a href="#四、函数的参数" class="headerlink" title="四、函数的参数"></a>四、函数的参数</h4><pre><code>(function ( a ) {
    console.log( a );
    var a = 10;
    console.log( a );
})( 100 );
</code></pre><blockquote>
<ul>
<li>函数定义参数，实际上就是在函数最开始的时候，有一个变量的声明 function（a）{}其含义就是，在已进入函数体，在所有操作开始之前（预解析之前）就有了该变量的声明</li>
</ul>
</blockquote>
<pre><code>(function ( a ) {
    console.log( a );
    var a = 10;
    console.log( a );
    function a () {
        console.log( a );
    }
    // a();
})( 100 );
</code></pre><ul>
<li>注意：先调用函数，函数内部才会开始预解析，相当于函数最开始的时候就有一个var a=100;</li>
</ul>
<p>###五、作用域链规则</p>
<blockquote>
<ul>
<li>什么是作用域链<br>就是在当前作用域链中如果要寻找一个内容，会先在当前作用域中寻找，如果没有找到就会渠道上一层作用域中继续寻找。。。一直找到全局作用域都没有的话，那么就找不到，报错。由于这种一环套一环的访问规则，这样的作用域构成一个链式结构，所以直接称其为作用域链<br>作用域链是用来做变量查找的，因此变量可以存储什么东西，链中就应该有什么东西，换句话说就是，链里面存储的是各种对象，可以将其想想成对象的序列（数组）</li>
<li>绘制作用域链的规则<ul>
<li>将所有的script标签作为一个链结构，标记为0级别的链</li>
<li>将全局范围内，所有的声明变量名和声明函数名按照代码的顺序标注在0级链中</li>
<li>由于每一个函数都 可以构成一个新的作用域链，所以每一个0级链上的函数都延展出1级链</li>
<li>分别在每一个函数中进行上述操作将函数中的每一个名字都标注在1级链中</li>
<li>每一条1级链中如果有函数，可以再次的延展出2级链，以此类推</li>
</ul>
</li>
<li>分析代码的执行<br> 当作用域链绘制完成后，代码的分析也需要一步一步的完成<ul>
<li>根据代码的执行顺序（从上往下，从左至右）在图中标记每一步的变量数据的变化</li>
<li>如果需要访问某个变量，直接在当前n级链上查找变量，查找无序</li>
<li>如果找到变量，直接使用，如果没有找到变量，在上一级，n-1级中查找</li>
<li>一直找下去，知道0级链，如果0级链还没有就报错，XXX is not defined；</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h4><blockquote>
<ol>
<li>混入——可以将一个对象的成员 混入 到另一个对象当中</li>
<li>混合式继承<ul>
<li>给原型对象添加一个混入的方法</li>
<li>使用混入的方法为原型对象添加成员</li>
<li>此时通过构造函数创建的对象就会继承原型当中的成员</li>
</ul>
</li>
<li>Object.create:以一个对象作为原型创建一个新的对象。优点——可以快速的创建一个相类似的对象</li>
<li>原型链结构：<ul>
<li>实例对象–》构造函数.原型–》Object.prototype–》null</li>
<li>内置对象–》内置对象构造函数.原型–》Object.prototype–》null</li>
<li>Object对象–》Object.prototype–》null</li>
</ul>
</li>
<li>动态函数：Function<ul>
<li>函数是一个对象，它应该也是由构造函数创建的，也应该有原型对象。Function就是函数（实例对象）的构造函数</li>
</ul>
</li>
<li>arguments对象<ul>
<li>对象中包含了传入的所有参数，他的length属性可以显示参数的个数</li>
</ul>
</li>
<li>函数.length——函数定义的时候参数的个数<br>函数.name——函数名</li>
<li>callee和caller<ul>
<li>callee：代表被调用的函数的引用</li>
<li>caller：代表调用函数的函数（调用者）</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="二、eval函数"><a href="#二、eval函数" class="headerlink" title="二、eval函数"></a>二、eval函数</h4><blockquote>
<ol>
<li>eval函数与Function功能类似，eval可以直接将字符串作为代码来执行<ul>
<li>语法：eval（语句字符串）</li>
<li>注意：它好像与当前代码处于同一个作用域</li>
<li>可以直接调用eval函数，来实现字符串代码</li>
</ul>
</li>
<li>eval函数和Function的比较<ul>
<li>A 语法特点<ul>
<li>eval简洁，直接调用即执行</li>
<li>Function是用来生成函数中的，所以如果要执行，需要调用</li>
<li>立即执行函数（自调用函数）</li>
</ul>
</li>
<li>B 作用域<ul>
<li>eval就在执行函数的当前作用域  </li>
<li>在eval函数中，使用字符串声明的变量，在eval函数外面可以立即使用，即eval函数的执行作用域与当前环境作用域一致</li>
<li>Function是创建了一个新的函数，那么所有的东西，都只在函数内部起作用，除非：<ul>
<li>变量没有声明，直接使用</li>
<li>return</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>eval函数转json格式的字符串为对象<ul>
<li>json格式（更加严格的，国际通用数据表示协议）</li>
<li>在js中使用的json对象，相对较松散</li>
<li>json格式有两种结构<ul>
<li>{}对象的结构</li>
<li>[]数组的结构</li>
<li>注意：json格式中，键名也必须使用双引号括起来，在js中就没有这个要求了，较松散</li>
</ul>
</li>
<li>将字符串变成对象，有三种做法<ul>
<li>eval做法 </li>
<li>Function做法</li>
<li>使用ES5中引入的标准处理JSON的语法</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code>//eval做法
var o1=eval(data)   //注意一个习惯，就是数据两端加上圆括号为好
//Function做法
var o2 =(new Function(&apos;return&apos;+data))();
//ES5
</code></pre><p>处理JSON的做法<br>    JSON.parse() //注意：字符串必须是严格的json格式，双引号</p>
<blockquote>
<ol>
<li>为何转换json格式字符串需要圆括号<ul>
<li>eval函数本质是执行js代码的</li>
<li>eval是用来执行字符串表示的js代码的，所以隐含的数据里面{}实际上是代码块的含义<br>标签语法，即使将字符串写成json格式的形式也不行</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code>/*
label:
while () {
    while () {
        while () {
            ... 
            break label;
        }
    }
}
...
*/
</code></pre><h4 id="三、函数是Function的实例"><a href="#三、函数是Function的实例" class="headerlink" title="三、函数是Function的实例"></a>三、函数是Function的实例</h4><blockquote>
<ul>
<li>function（对象角度）是Function（构造函数）的实例</li>
<li>在该角度去看，函数就是对象，Function就是构造函数</li>
<li>函数对象（构造函数，系统函数，自定义函数）都是由Function创建出来的实例对象，即所有函数都是Function构造出来的实例</li>
<li>Function也是一个函数对象，它是由自己构造出来的，即Function是由Function构造出来的实例</li>
</ul>
</blockquote>
<h4 id="四、instanceof-运算符"><a href="#四、instanceof-运算符" class="headerlink" title="四、instanceof 运算符"></a>四、instanceof 运算符</h4><blockquote>
<ul>
<li>语法——返回的是boolean值 </li>
<li>对象 instanceof 构造函数</li>
<li>判断构造函数的原型属性，是否在对象的原型链上</li>
<li>A instanceof B——判断B的原型是否在A对象的原型链上</li>
</ul>
</blockquote>
<h4 id="五、不要过多依赖原型链"><a href="#五、不要过多依赖原型链" class="headerlink" title="五、不要过多依赖原型链"></a>五、不要过多依赖原型链</h4><blockquote>
<ul>
<li>js的继承：就是利用对象的动态特性添加成员，或直接替换对象的方式修改原型链结构，使得当前对象的原型链上的对象具有某些成员，那么我的当前对象就可以使用这些成员了<ul>
<li>过多的依赖原型链继承，会损耗性能</li>
<li>如果必须使用原型链继承，最好提供一些快速访问的方法</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="六、代码预解析"><a href="#六、代码预解析" class="headerlink" title="六、代码预解析"></a>六、代码预解析</h4><blockquote>
<ul>
<li>编译性语言：C，C++，C#，Java 就是需要一个‘翻译’程序，将源代码翻译成计算机可以读懂的二进制数据（指令）。然后存储成可执行文件。<br>提前翻译好，运行时直接执行的结果</li>
<li>解释型（脚本型）：javascript，SQL，……<br>代码在执行的时候，有一个翻译程序，读一句代码执行一句代码，再读一句代码，再执行一句代码</li>
<li>代码在执行之前，需要快速的‘预览’一遍，那么可以尽可能提高执行效率</li>
<li>在js中预解析的特点<ul>
<li>代码是如何执行的：读取js文件，预解析，一句一句执行</li>
<li>js在预解析的过程中完成了声明部分的标记与变量作用域的设定</li>
</ul>
</li>
<li>什么是js中的声明<ul>
<li>简单的说就是让js执行引擎知道有什么东西（标识符）</li>
<li>即代码在执行之前的预解析，首先让js的执行引擎在当前运行环境中，有什么东西（名字、标识符）是可以被使用的</li>
<li>console.log（num）</li>
</ul>
</li>
<li>在js中有哪些声明<br>标识符的声明（变量的声明）<br>函数的声明</li>
<li>变量的声明<ul>
<li>语法 ： var 变量名</li>
<li>目的：告诉解释器，有一个名字是一个变量，在当前环境中可以被使用</li>
</ul>
</li>
<li>语句：就是可以执行的东西，在代码执行的时候才会区运行<ul>
<li>var a = 123;凡是要去执行的东西都是一个语句，在使用var 声明变量，同时完成赋值的时候，实际上，预解析将其做了一定处理：</li>
<li>凡是读取到var的时候，就检查var紧跟的名字是否已经标记了</li>
<li>如果没有标记，就表明这个名字是一个标识符，需要被标记</li>
<li>如果已经被标记了，那么这个var被忽略</li>
</ul>
</li>
</ul>
</blockquote>
<p>结论：<br>  var a;<br>  var a=10;<br>等价于  var a; a=10;</p>
<h4 id="七、预解析的特点——变量名提升"><a href="#七、预解析的特点——变量名提升" class="headerlink" title="七、预解析的特点——变量名提升"></a>七、预解析的特点——变量名提升</h4><blockquote>
<ul>
<li>注意：‘字符串’ in 对象——该字符串描述的名字，是否在对象中存在一个属性，与之同名</li>
</ul>
</blockquote>
<pre><code>if( &apos;a&apos; in window ){
  var a=123;
}
console.log(a); //123;
</code></pre><h4 id="八、函数的声明"><a href="#八、函数的声明" class="headerlink" title="八、函数的声明"></a>八、函数的声明</h4><blockquote>
<ul>
<li>函数的各种定义形式<ul>
<li>声明式：function func(){}</li>
<li>表达式式（匿名函数，字面量函数，lambda函数）<br>var func=function(){};</li>
</ul>
</li>
<li>特点：<ul>
<li>函数的声明是独立于语句的，不需要加分号结束，也不能嵌入到代码表达式中</li>
<li>表达式式，本质上是使用函数表达式（字面量）给变量赋值，因此它是语句</li>
</ul>
</li>
<li>表达式：<ul>
<li>将运算符与操作数连接起来的式子</li>
<li>就是一个有结果的代码单元</li>
<li>字面量，有值，是表达式，是常量表达式</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="九、函数各种定义形式的异同"><a href="#九、函数各种定义形式的异同" class="headerlink" title="九、函数各种定义形式的异同"></a>九、函数各种定义形式的异同</h4><blockquote>
<ul>
<li>声明式（重点是语法）<ul>
<li>function func（）{}</li>
<li>函数声明是独立于代码执行的，代码在执行的时候，声明部分已在预解析阶段处理完毕，因此在代码调试阶段，无法给函数声明添加断点，而且由于预解析在执行之前完成，可以先调用，后声明函数，有时在开发的时候，将函数全部声明在后面，前面为了保证代码的紧凑，而直接调用。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="十、预解析的特点——各种函数定义形式的异同"><a href="#十、预解析的特点——各种函数定义形式的异同" class="headerlink" title="十、预解析的特点——各种函数定义形式的异同"></a>十、预解析的特点——各种函数定义形式的异同</h4><blockquote>
<ul>
<li>函数表达式<ul>
<li>使用这个方式定义函数，实际上是利用函数是js中的 一个数据类型的特点</li>
<li>利用赋值，使用变量存储函数的引用，此时没有函数的声明，但是有变量的声明</li>
<li>读取代码，发现 var func，存储func这个名字</li>
<li>开始执行代码，第一句是赋值语句，将函数赋值给func<br>执行</li>
<li>如果将调用放到赋值之前，就会报错</li>
</ul>
</li>
<li>函数表达式的名字问题<ul>
<li>函数.name可以用来获取函数的名字，表达式没有名字<br>我们的函数表达式也是可以带有函数名</li>
<li>var 函数名1=function 函数名2（）{}</li>
<li>当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式</li>
<li>引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数</li>
<li>函数表达式带有名，该名字只允许在函数内部使用，属于局部作用域</li>
<li>带有名字的函数表达式，函数的name属性即为该名字</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<ol>
<li><p>解决方案：</p>
<ul>
<li>使用js原生自带的一个对象，原型对象。</li>
<li>每一个函数，在创建的时候，就自带 了一个prototype属性，通过prototype就可以访问原型对象</li>
<li>在对象创建的时候，对象会默认创建一个原型对象，当执行对象方法的时候，对象没有这个东西，就会去在原型上找</li>
</ul>
</li>
<li><p>什么东西应该被加载原型上面，什么东西应该被放在对象中</p>
<ul>
<li>假设这个方法是公用的（所有的对象都拥有的功能），数据是共享的，那么它就应该被放到原型中，独有的数据，独有的行为应该被放在对象中</li>
</ul>
</li>
<li><p>针对构造函数而言，原型就是构造函数的prototype属性，常常将其称为原型属性，针对实例对象而言，原型就是实例对象的原型对象。</p>
</li>
<li><p>一般如何使用原型对象</p>
<ul>
<li>简单的说就是将共享的方法放到原型中，而独有的数据与行为放在当前对象里<br>①直接通过动态特性给原型对象添加成员，例如：Person.prototype.eat<br>②直接替换原型对象，让 Person.prototype 指向另一个对象. 直接赋值 如：Person.prototype={constructor:Person,};（注意：手动的添加constructor属性，表示对应的构造函数）</li>
</ul>
</li>
</ol>
<p>A方法是给系统提供的原型对象添加功能<br>B方式是换了一个对象，不适用系统的对象了</p>
<ol>
<li><p><strong>proto</strong></p>
<ul>
<li>早期浏览器是不支持<em>proto</em>，火狐率先使用该属性，但是是非标准的</li>
<li>基本现在的新浏览器都支持该属性（ie8不支持该属性）</li>
<li>在实际开发中不建议使用，但可以用于调试<br>访问</li>
<li>使用构造函数，就使用prototype属性访问原型</li>
<li>使用实例对象，就使用非标准的<em>proto</em>属性访问原型<br>其实他们访问的是一个东西</li>
</ul>
</li>
<li><p>兼容低版本</p>
<ul>
<li>使低版本浏览器支持<br>第一步：判断系统是否支持<em>proto</em><br>if({}.<em>proto</em>){cl(‘支持’);}else{cl(‘不支持’);}<br>为了模拟该用法，不适用<em>proto</em> 去访问原型<br>要访问原型最保险的办法就是利用构造函数，只要实例对象，可以访问到constructor就可以了</li>
</ul>
</li>
</ol>
<p>如果实例对象没有这个东西，会去原型上找<br>p1.constructor.prototype</p>
<ol>
<li><p>继承的概念与原型式继承</p>
<ul>
<li>什么是继承<br>自己没有，但是别人有，拿过来自己用，就好像是自己的一样</li>
<li>原型与实例对象<br>在js中，方法定义在原型对象中，而属性定义在实例对象中，调用方法的时候，实例对象本身是没有该成员的，但是依旧可以调用该方法，好像这个方法就是该实例对象的一样，因此，我们称该实例对象继承自原型对象</li>
<li>任何一个实例，都是继承自其原型对象的，即原型式继承</li>
</ul>
</li>
<li><p>为什么需要继承</p>
<ul>
<li>编程的发展<br>复用（重复使用）</li>
<li>js运行效率<br>共享特性<br>复用<br>组件化  菜单的一套控件</li>
</ul>
</li>
<li><p>传统面向对象语法特征</p>
</li>
<li><p>相关概念与说明<br>构造函数：本质上是一个函数，但是我们可以通过new来调用这个函数并且创建一个实例对象<br>实例对象：本质上是一个对象{}，但是我们是通过构造函数来创建的实例对象，通过构造函数的参数我们可以给实例对象添加一些成员<br>实例成员：就是实例对象的属性或者方法<br>静态成员：指的是构造函数的属性或者方法，什么东西会设置成静态的成员呢？比如说工具方法</p>
</li>
<li><p>属性搜索原则（成员搜索原则）</p>
<ul>
<li>对象在调用方法或者访问属性的时候，首先在当前对象中查询，如果有该成员使用并停止查找</li>
<li>如果没有该成员，就在其原型对象中查找，如过有该成员即使用并停止查找</li>
<li>如果还没有找到，就到该对象的原型对象的原型对象中查找<br>…………</li>
<li>最后会查到Object.prototype上，如果还没有即返回undefined;</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/02/12/jQuery/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天看到这样一句jquery源码<br><code>(function (window, undefined){})(window)</code></p>
</blockquote>
<ul>
<li>第一眼：这是啥？</li>
<li>第二眼：这是干啥？</li>
<li>第三眼：为啥？</li>
<li><p>然后……</p>
<a id="more"></a>
</li>
<li><p>终于在各种资料查询</p>
</li>
<li><p>勇敢抱大腿后</p>
</li>
<li><p>拨开云雾见青天</p>
</li>
<li><p>必须得了个瑟~</p>
</li>
<li><p>ECMAScript执行JS代码是从里到外</p>
</li>
<li>因此把全局变量<em>window</em>对象传进来</li>
<li>就避免了到外层去寻找</li>
<li>减少作用域链的查询时间，提高效率</li>
<li>当然</li>
<li><p>如果你的插件用不到<em>window</em>对象，那么就不用传递这个参数啦</p>
</li>
<li><p>而且<br><code>(function(window, undefined))里的window和undefined</code></p>
</li>
<li>均可以替换成其他简写字符（比如L）</li>
<li>那么在压缩的时候可以减少字节数</li>
<li><p>即可以减少文件大小</p>
</li>
<li><p>再说回<em>undefined</em></p>
</li>
<li>在旧的浏览器中<em>undefined</em>可以被重新赋值</li>
<li>在被重新赋值后,使用<em>undefined</em>指令将不能正确的检测一个变量是否被赋值</li>
<li>总之，会影响到内部的<em>undefined</em></li>
<li>jQuery框架考虑到这个问题</li>
<li><p>因此增加一个形参<em>undefined</em></p>
</li>
<li><p>使用时最好就是不传实际参数</p>
</li>
<li>此时形参的<em>undefined</em>就是真正的<em>undefined</em>了</li>
<li>记住，这里不是在说绕口令哦~</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/02/12/HTML5%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="基础API提升"><a href="#基础API提升" class="headerlink" title="基础API提升"></a>基础API提升</h4><ul>
<li>document.getElement……appendChild……都属于基础API</li>
<li>alt +右键往下滑</li>
<li><p>新选择器</p>
<ul>
<li><code>document.querySelector(selector)</code>——返回第一个满足选择器条件的元素，返回一个dom对象<ul>
<li>代码段 qs=querySelector</li>
<li>ae=addEventListenter</li>
</ul>
</li>
<li><code>docuemnt.querySelectorAll(&quot;.item&quot;)</code>——返回所有满足该条件的元素，返回元素类型为dom对象的数组</li>
<li>$（”.item”）——返回一个jQuery对象（dom元素的数组）</li>
<li>本质上jQuery的方式和querySelector的方式都是获取DOM数组，只不过jQuery会多一些其它成员</li>
<li>DOM数组的每一个成员注册事件不能像jQuery一样直接注册，必须分别给每个元素添加</li>
<li>h5就是将我们经常需要的操作又包装一层，原生API</li>
</ul>
<a id="more"></a>
</li>
<li><p>Element.classList</p>
<ul>
<li>新H5中DOM对象多了一个classList属性，是一个数组</li>
<li>a标签有个默认跳转</li>
<li>this.classList.add()——添加一个新的类名</li>
<li>this.classList.remove()——删除一个类名</li>
<li>this.classList.contains()——判断是否包含一个指定的类名</li>
<li><p>this.classList.toggle()——切换一个class</p>
<ul>
<li>toggle函数的第二个参数true为添加，false删除</li>
</ul>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断当前classList中有没有active</span></div><div class="line"><span class="keyword">var</span> link=<span class="built_in">document</span>.querySelector(<span class="string">".bar"</span>);</div><div class="line">link.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="comment">//toggle函数的第二个参数是true为添加，false为删除</span></div><div class="line">  <span class="keyword">var</span> exist =<span class="keyword">this</span>.classList.contains(<span class="string">"active"</span>);</div><div class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">"active"</span>,!exist);</div><div class="line">  e.preventDefault();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问历史API</p>
<ul>
<li><p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态</p>
</li>
<li><p>go函数可以传入一个地址，不传默认刷新</p>
</li>
<li><p>window.history.forward()</p>
</li>
<li><p>auto file name(插件plugin名字)</p>
</li>
<li><p>不建议用*号把默认样式去掉，效率低</p>
</li>
<li><p>默认样式有必要，只不过为了统一设置</p>
</li>
<li><p>当我们在伪造的访问历史中前进或后退时会执行一个popstate事件。</p>
</li>
<li><p>通过JS可以加入一个访问状态</p>
</li>
<li><p>history.pushState(放入历史中的状态数据，设置title（现在浏览器不支持）)</p>
</li>
<li><p>window.location可以拿到当前网页中跟地址相关的信息（location是个对象）  hash是锚点值</p>
</li>
<li><p>decodeURI作用就是从URL编码转换到之前的状态</p>
</li>
<li><p>encode反作用</p>
</li>
<li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"add()"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加一个历史记录"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//判断浏览器是否支持这个API</span></div><div class="line">      <span class="keyword">if</span>(<span class="built_in">window</span>.history &amp;&amp; history.pushState)&#123;</div><div class="line">        history.pushState(<span class="string">"数据"</span>,<span class="string">"设置历史状态显示的标题，但是浏览器不支持"</span>，<span class="string">"？demo="</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().toLocalTimeString());</div><div class="line">      &#125;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>new Date()  获取的是一个时间对象</p>
</li>
<li><p>toLocalTimeString 转换成我们能认识的时间字符串</p>
</li>
<li><p>toDateTimeString 转换成我们能认识的日期字符串</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> title=<span class="built_in">window</span>.location.search.split(<span class="string">"="</span>)[<span class="number">1</span>];</div><div class="line"><span class="keyword">if</span>(title)&#123;</div><div class="line">  <span class="comment">//有值</span></div><div class="line"> <span class="comment">//如果地址栏中的地址有中文，会以URL编码方式呈现</span></div><div class="line">  content.innerHTML=data[<span class="built_in">decodeURI</span>(data)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>class</p>
<ul>
<li><p>之前</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h1=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> list =h1.className.split(<span class="string">" "</span>);</div><div class="line">list.push(<span class="string">"class4"</span>);</div><div class="line">h1.className=list.join(<span class="string">" "</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>通过dom对象的classList，className是字符串的形式，classList是数组的形式</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h1=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> list=h1.classList</div></pre></td></tr></table></figure>
</li>
<li><p>通过classList封装了一些针对增加、删除、切换的方法——add(“newclass”)； remove(“oldclass”)； toggle(“cl”)  存在则删除，不存在添加；contains()是否包含</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>控制台clear（）</p>
<h4 id="全屏API"><a href="#全屏API" class="headerlink" title="全屏API"></a>全屏API</h4><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = 需要全屏的元素；</div><div class="line"><span class="keyword">if</span>(&#123;elem.webkitRequestFullScreen)&#123;</div><div class="line">  elem.webkitRequestFullScreen();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.mozRequestFullScreen)&#123;</div><div class="line">  elem.webkitRequestFullScreen();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.requestFullScreen)&#123;</div><div class="line">  elem.requestFullScreen();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>需要操作用户的界面的时候，都需要得到用户的允许</p>
</li>
<li><p>if()return  不写{}，只能在单句代码的时候才可以这样操作</p>
</li>
<li><p>在全屏后，背景颜色会不起作用，得单独设置</p>
</li>
<li><p>给元素全屏或者document.body全屏</p>
</li>
</ul>
<h4 id="网页存储"><a href="#网页存储" class="headerlink" title="网页存储"></a>网页存储</h4><ul>
<li><p>application cache——可以让网页离线访问</p>
</li>
<li><p>google开发工具有个功能可以断开网络——network》》no throttling 》可以模拟网络</p>
</li>
<li><p>tab键不起作用时，可以用Ctrl+E</p>
</li>
<li><p>：：before是元素一开始的时候，在元素内部</p>
</li>
<li><p><code>&lt;html lang=&quot;en&quot; manifest=&quot;cache.mainfest&quot;&gt;</code>——manifest属性对应指向一个文件，这个文件称之为H5的缓存清单。这个路径是相对路径</p>
<ul>
<li><p>应用程序缓存 正常开发</p>
</li>
<li><p>给html添加一个manifest属性指向一个文件</p>
</li>
<li><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CACHA MANIFEST</div><div class="line"><span class="meta"># version 1.0.0</span></div><div class="line"><span class="symbol"></span></div><div class="line">CACHA:<span class="comment">//代表缓存下可以访问的文件，哪些文件可以缓存下来</span></div><div class="line">	index.html<span class="comment">//这里需要缩进</span></div><div class="line">	script.js</div><div class="line">	style.css</div><div class="line"><span class="symbol"></span></div><div class="line">NETWORK:<span class="comment">//哪些文件在有网络的情况下可以访问</span></div><div class="line">	*</div></pre></td></tr></table></figure>
</li>
<li><p>markdown编辑器，可以离线访问，得之前访问过，有过缓存才可以</p>
</li>
</ul>
</li>
</ul>
<h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul>
<li><p>localStorage(生命周期是永久的) &amp; sessionStorage（浏览器结束的时候就没有了，用法是一样的）</p>
</li>
<li><p>getItem方式获取一个不存在的键，返回空字符串，而[]返回undefined</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btnSet = <span class="built_in">document</span>.querySelector(<span class="string">"#btn_set"</span>);</div><div class="line"><span class="keyword">var</span> btnGet = <span class="built_in">document</span>.querySelector(<span class="string">"#btn_get"</span>);</div><div class="line"><span class="keyword">var</span> txtValue = <span class="built_in">document</span>.querySelector(<span class="string">"#txt_value"</span>);</div><div class="line">btnGet.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//txtValue.value=localStorage.getItem("key1");</span></div><div class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)</div><div class="line">  txtValue.value=localStorage(<span class="string">"key1"</span>);</div><div class="line">&#125;);</div><div class="line">btnSet.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//localStorage.setItem("key1",txtValue.value);</span></div><div class="line">  localStorage[<span class="string">"key1"</span>]=txtValue.value;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>id以下划线，class以中划线</p>
</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>提供客户端本地操作文件的可能</li>
<li>file API</li>
<li>文件域 <input type="file" id="" multiple></li>
<li>对于表单里的input来说：可以直接通过表单的name属性找到它</li>
<li>document.form[0].input_file</li>
<li>multiple是让文件域可以多选</li>
<li>可以通过在控制台输入document.form[0].input_file.files 可以查看已经上传的文件，以数组的形式呈现</li>
<li>lastModified——表示最近修改时间</li>
<li>lastModifiedDate——date对象</li>
<li>​:happy: v3.bootcss.com</li>
<li>js里面常用单引号</li>
</ul>
<h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h4><ul>
<li>支持网页内的拖放</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/01/12/HTML5%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="浏览器与服务器之间的交互过程"><a href="#浏览器与服务器之间的交互过程" class="headerlink" title="浏览器与服务器之间的交互过程"></a>浏览器与服务器之间的交互过程</h5><ol>
<li><p>用户在浏览器的地址栏中输入网站的地址</p>
</li>
<li><p>浏览器将请求报文发送给地址栏中网站的服务器</p>
</li>
<li><p>服务器根据请求报文返回页面数据给浏览器</p>
</li>
<li><p>浏览器得到响应的数据以后将之呈现给用户</p>
</li>
</ol>
<h5 id="请求报文和响应报文——审查元素-》network"><a href="#请求报文和响应报文——审查元素-》network" class="headerlink" title="请求报文和响应报文——审查元素 》network"></a>请求报文和响应报文——审查元素 》network</h5><ol>
<li><p>请求报文：浏览器发送给服务器的</p>
</li>
<li><p>响应报文：服务器返回给浏览器的</p>
</li>
</ol>
<a id="more"></a>
<h5 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h5><ul>
<li>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。</li>
<li>浏览器内核（Rendering Engine）：负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>IE：trident；  Safari：webkit；Firefox：gecko；chrome、Opera：blink</li>
</ul>
<h5 id="文件的后缀名"><a href="#文件的后缀名" class="headerlink" title="文件的后缀名"></a>文件的后缀名</h5><ul>
<li>修改文件的后缀名是不会改变内容，只决定打开方式</li>
<li>H系列标签作用：把页面上的文字加上标题的语义</li>
</ul>
<h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul>
<li>http协议<ul>
<li>请求报文</li>
<li>响应报文</li>
<li>URL：协议名、服务器的IP地址、端口号、请求文件的名称</li>
</ul>
</li>
<li>浏览器接受用户操作——浏览器封装HTTP请求——链接服务器：DNS解析——发送请求Request——服务器接收请求——处理请求——返回响应报文——浏览器接收响应报文——渲染页面呈现</li>
<li>如果没有设置端口号那么默认的端口是：80</li>
</ul>
<p>图片是另外请求</p>
<p>继续渲染与请求服务器的图片</p>
<h5 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h5><ul>
<li>img：图片标签</li>
<li>src：标签的属性，设置图片的路径</li>
<li>Alt：如果图片不存在，设置图片的文本信息</li>
<li>title：设置图片的提示信息，当鼠标悬停在图片上方的时候，就会显示提示信息</li>
</ul>
<h5 id="访问有图片的网页时，浏览器和服务器的交互过程"><a href="#访问有图片的网页时，浏览器和服务器的交互过程" class="headerlink" title="访问有图片的网页时，浏览器和服务器的交互过程"></a>访问有图片的网页时，浏览器和服务器的交互过程</h5><ul>
<li>用户在地址栏中输入一个网页的网址，按回车</li>
<li>浏览器就会向这个地址的服务器发送一个请求报文</li>
<li>服务器根据请求报文返回网页的页面数据给浏览器</li>
<li>浏览器解析返回的响应报文，并渲染显示</li>
<li>当浏览器解析到图片的时候，它不知道图片是在哪里的，所以，浏览器会再发送一次请求报文，去请求服务器的那一张图片</li>
<li>然后等待服务器返回图片的响应的时候，浏览器还会继续解析下面的其它内容</li>
</ul>
<h5 id="路径分为两种情况"><a href="#路径分为两种情况" class="headerlink" title="路径分为两种情况"></a>路径分为两种情况</h5><ul>
<li>绝对路径：从盘符开始寻找路径</li>
<li>相对路径：从当前页面开始寻找路径</li>
</ul>
<h5 id="a标签使用的地方"><a href="#a标签使用的地方" class="headerlink" title="a标签使用的地方"></a>a标签使用的地方</h5><ul>
<li>空连接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></li>
<li>去到其它的网页：<code>&lt;a href=&quot;其它的网页.html&quot;&gt;</code></li>
<li>去到其它页面的某一个地方，在跳转的页面进行定位 <code>&lt;a href=&quot;其它的网页.html#id&quot;&gt;</code></li>
<li>去到本页面的某一个地方：<code>&lt;a href=&quot;#id&quot;&gt;</code></li>
<li>下载（不建议）</li>
</ul>
<h5 id="a标签的属性target"><a href="#a标签的属性target" class="headerlink" title="a标签的属性target"></a>a标签的属性target</h5><ul>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_blank&quot;&gt;将会用新的页面打开1.html&lt;/a&gt;</code></li>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_self&quot;&gt;将会在当前的页面打开1.html&lt;/a&gt;</code></li>
<li>base 为页面上所有a标签设置跳转的方式（base标签一般放在title下面，写在head里面）<code>&lt;base target=&quot;_blank&quot;&gt;</code></li>
</ul>
<h5 id="DOCTYPE文档类型"><a href="#DOCTYPE文档类型" class="headerlink" title="DOCTYPE文档类型"></a>DOCTYPE文档类型</h5><ul>
<li>DTD 文档类型定义</li>
<li>html和XHTML规范<ul>
<li>html：3种<ul>
<li>strict</li>
<li>transitional（用的最多）</li>
<li>frameset</li>
</ul>
</li>
<li>XHTML：3种</li>
</ul>
</li>
<li>lang 用来设置当前页面的语言<ul>
<li>设置页面上主要使用语言的类型</li>
<li>将来做SEO的时候在权重上起到一定的作用</li>
<li>用于特殊设备上的设置，eg，盲人设备</li>
</ul>
</li>
</ul>
<h5 id="关于SEO"><a href="#关于SEO" class="headerlink" title="关于SEO"></a>关于SEO</h5><ul>
<li>搜索引擎优化（网站在搜索页面上的排名靠前）<ul>
<li>买排名，不靠谱</li>
<li>将页面做成静态页面（html）</li>
<li>发外链</li>
<li>页面的友好性（规范）：在合适的地方使用合适的标签，合理的使用标签的语义化</li>
</ul>
</li>
<li>讨好搜索引擎<ul>
<li>网络爬虫，搜索引擎机器人：收录Internet上的网站，找到访问量高的，语义化好的网站，最后将这些网站作为搜索的结果呈现给用户观看  任务：就是用来访问页面给页面排序，从而在用户搜索的时候可以有一个先后的排名</li>
</ul>
</li>
<li><p>让网站更靠前的方式：</p>
<ul>
<li>买排名，不靠谱</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h5><ul>
<li>作用：让页面拥有一个属于自己的标题</li>
<li>title中的文本在SEO中占有很大的权重</li>
<li>h1,h2</li>
</ul>
<h5 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h5><ul>
<li>注意：meta中设置的所有的内容在页面都不会显示，</li>
</ul>
<ul>
<li><p>description 可以描述页面，可以用来使用百度程序（网络爬虫）来收录关键信息，以此提高页面的排名</p>
</li>
<li><p>keywords  关键词，可以用来提高页面的关键词的比重的一种方式，:angry:英文的逗号</p>
</li>
<li><p>最多不要超过十个</p>
</li>
<li><p>charset</p>
<ul>
<li><p>字符集：相当于一个字库，在这个字库有很多的文字，每一个文字都有对应的编码</p>
</li>
<li><p>当你设置的网页的编码格式和保存的编码格式不一样的时候，就会发生乱码</p>
</li>
<li><p>gb2312：国际标准，收录了汉字，片假名</p>
</li>
<li><p>gbk：国标扩（扩展版），一个文字2个字节</p>
</li>
<li><p>UTF-8：收录全世界所有的语言中的文字，一个文字3个字节</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul>
<li>无序列表<ul>
<li>ul标签的作用：表示在这里有一个无序的列表</li>
<li>li标签的作用：表示列表的项</li>
<li>注意：ul不能单独出现，ul里面一定要放li，li是一个容器，放什么其他的标签都可以</li>
</ul>
</li>
<li>有序列表<ul>
<li>作用：显示一段有顺序的数据</li>
<li>语义：一组有顺序的数据</li>
</ul>
</li>
<li>自定义列表：dl,dt,dd<ul>
<li>dl标签：写一个自定义列表</li>
<li>dt标签：它代表的就是这儿有一个自定义的列表项</li>
<li>dd标签：代表dt对应的列表项中的具体内容</li>
</ul>
</li>
</ul>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><ul>
<li><p>table标签：表示是一个表格的内容</p>
</li>
<li><p>tr标签：表示是表格中的一行</p>
</li>
<li><p>td标签：表示是表格中的一个单元格</p>
</li>
<li><p>表格的其它标签和属性：</p>
<ul>
<li>表格的属性：<table border="1" cellspacing="" cellpadding=""> <ul>
<li>border：设置表格的边框的宽度 </li>
<li>cellspacing：设置的是表格中的单元格之间的距离</li>
<li>cellpadding：设置的是单元格中的内容与单元格之间的距离</li>
<li>width</li>
<li>height</li>
</ul>
</table></li>
</ul>
</li>
<li><p>表格中的其他标签</p>
<ul>
<li>th标签：设置表头，具体表现的效果是文字加粗，居中</li>
<li>caption标签：设置标题的标题，注意，caption标签应该放在table标签后面</li>
<li>thead标签：设置的是表格的头部信息，一般th的内容都应该放在这里</li>
<li>tbody标签：设置的是表格的主题内容，一般td的内容都放在这里</li>
<li>tfoot标签：设置的是表格的尾部信息，一般是放一些总结性的信息</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h5><ul>
<li><code>&lt;input type=&quot;hidden&quot; value=&quot;&quot;&gt;</code> 学习ajax时候用到</li>
<li><input type="text" value="默认值">：输入框</li>
<li><input type="password">：密码框</li>
<li><input type="hidden" value="隐藏的数据">：隐藏域</li>
<li><input type="radio">：输入框</li>
<li>注意：如果单选按钮要真正做到单选的效果，需要进行分组。通过name属性，可以将多个单选按钮设置为一组</li>
<li>默认选中 checked=”checked”</li>
<li><input type="checkbox" checked="checked" name="hobby">：复选框</li>
<li><input type="button" value="按钮上的文字">：设置一个普通按钮</li>
<li><input type="image" value="图像的路径">：设置一个图像按钮（图像域），按钮的图片需要通过src来进行设置</li>
<li><input type="submit">：提交按钮</li>
<li><input type="reset">：重置按钮</li>
<li>注意：不管是提交还是重置，都要先有一个表单<form></form></li>
<li>下拉框</li>
<li>文本域</li>
</ul>
<p>注意：1. reset如果不设置value值，会有默认值<br>        2.reset、submit等需要和form标签配合使用，否则不会有效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML基础知识（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2014/12/14/HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="html中的空格合并"><a href="#html中的空格合并" class="headerlink" title="html中的空格合并"></a>html中的空格合并</h4><ul>
<li>空格合并：在html源代码里面写的空格，换行，tab，浏览器解析的时候不敏感，再多的连续的空格，换行，tab浏览器只会解析成一个空格。</li>
</ul>
<ul>
<li>如果想要多个空格，使用特殊字符——字符实体<ul>
<li><code> </code>一个中文字符的位置</li>
<li><code>&lt;</code> &lt;</li>
<li><code>&gt;</code> &gt;</li>
<li><code>&amp;</code> &amp;符号</li>
<li><code>©</code> 版权</li>
<li><code>®</code> 商标</li>
</ul>
</li>
</ul>
<p><a id="more"></a>  ​</p>
<h4 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h4><ul>
<li>一行可以放多个标签，span标签的大小由内容决定</li>
</ul>
<h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><ul>
<li>一个div标签会占一行的位置，高度是由内容决定的，宽度就是一整行</li>
</ul>
<h4 id="三层分离"><a href="#三层分离" class="headerlink" title="三层分离"></a>三层分离</h4><ul>
<li>html结构层</li>
<li>css样式层</li>
<li>javascript行为层</li>
</ul>
<h4 id="html语义化的好处"><a href="#html语义化的好处" class="headerlink" title="html语义化的好处"></a>html语义化的好处</h4><ul>
<li>SEO优化</li>
<li>让我们自己编写代码的时候会更加的清晰</li>
</ul>
<h4 id="CSS的初体验"><a href="#CSS的初体验" class="headerlink" title="CSS的初体验"></a>CSS的初体验</h4><ul>
<li>css代码写在style标签里，style标签放在head标签里面，title标签后面</li>
</ul>
<h4 id="字体相关的属性"><a href="#字体相关的属性" class="headerlink" title="字体相关的属性"></a>字体相关的属性</h4><ul>
<li>浏览器默认宋体</li>
<li>font-size：设置字体的大小</li>
<li>font-weight：设置字体的粗细。设置数值（100-900，只可以用整数，以每个字体类型为标准）或者关键词</li>
<li>font-family：设置字体</li>
<li>font-style：设置斜体</li>
</ul>
<h4 id="font"><a href="#font" class="headerlink" title="font"></a>font</h4><ul>
<li>font连写：font-style font-weight font-size font-family</li>
<li>一次性font属性可以设置多个css效果。像这种一次可以设置多个效果的属性叫做复合属性</li>
</ul>
<h4 id="颜色表示方式"><a href="#颜色表示方式" class="headerlink" title="颜色表示方式"></a>颜色表示方式</h4><ul>
<li><p>使用颜色的单词来设置颜色</p>
</li>
<li><p>十六进制</p>
</li>
<li><p>RGB<br>​</p>
</li>
</ul>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul>
<li>选择器的作用：选择html的内容，为其设置css</li>
</ul>
<ul>
<li><p>标签选择器：直接在选择器的部分写上标签名，此时，当前页面的该标签都会被选中来设置css</p>
</li>
<li><p>类选择器的使用方式</p>
<ul>
<li>给标签设置class=类名</li>
<li>设置类选择器样式</li>
</ul>
</li>
<li><p>id选择器的使用方式</p>
<ul>
<li>给标签设置id=id名</li>
<li>设置id选择器的样式</li>
</ul>
<p>注意：元素的id是唯一的</p>
<p>id不是给css用的，而是JavaScript</p>
</li>
<li><p>命名规范</p>
<ul>
<li>取名的时候可以使用的字符：0-9，a-z，A-Z，_，-</li>
<li>取名的时候不能用数字开头</li>
<li>潜规则：这个类选择器是干什么用的就取什么名字</li>
</ul>
</li>
<li><p>通配符选择器的使用方式</p>
<ul>
<li>*</li>
<li>作用：选择页面中所有的标签去设置一些统一的样式</li>
<li>效率比较低，不建议使用</li>
</ul>
</li>
<li><p>并集选择器 </p>
<ul>
<li>同时选择多个内容设置同一个样式</li>
<li>如果需要设置一些统一的样式，用并集选择器</li>
</ul>
</li>
<li><p>交集选择器</p>
</li>
<li><p>后代选择器：选中某些元素下面的符合条件的其它元素，不管是直接子元素还是非直接子元素，都会选中</p>
<ul>
<li>div p 选择了div标签下面的p标签</li>
</ul>
</li>
<li><p>子代选择器：选中某些元素下面的符合条件的其它元素，但必须是直接子元素  &gt;</p>
</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>注释不可以嵌套</li>
</ul>
<h4 id="添加CSS的三种方式"><a href="#添加CSS的三种方式" class="headerlink" title="添加CSS的三种方式"></a>添加CSS的三种方式</h4><ul>
<li><p>嵌套样式</p>
</li>
<li><p>行内样式：把css写在style属性里</p>
<ul>
<li>多个样式之间用分号隔开</li>
</ul>
</li>
<li><p>外联样式：把css写在另外一个文件里</p>
<p>注意：中文的空格占两个字母的空间（全角）</p>
</li>
</ul>
<h4 id="三种样式的使用场景"><a href="#三种样式的使用场景" class="headerlink" title="三种样式的使用场景"></a>三种样式的使用场景</h4><ul>
<li>行内：单独给一个标签设置样式的时候，不经常使用</li>
<li>嵌套：设置的样式只给当前的网页使用，假如你编写的样式只有当前页面会使用到，那么请使用嵌套样式</li>
<li>外联：设置的样式可以给多个网页使用，假如你写的样式在多个页面都会被使用到，就使用外联样式</li>
</ul>
<h4 id="text相关三个属性"><a href="#text相关三个属性" class="headerlink" title="text相关三个属性"></a>text相关三个属性</h4><ul>
<li>text-indent：文本的首行缩进<ul>
<li>em：单位，1个em相当于一个文字的大小</li>
</ul>
</li>
<li>text-align：文本的对齐方式（right，center，left）</li>
<li>text-decoration： 设置文本的装饰线</li>
<li>margin：0 auto <ul>
<li>作用：使容器在页面里居中显示</li>
</ul>
</li>
</ul>
<h4 id="css三大特性"><a href="#css三大特性" class="headerlink" title="css三大特性"></a>css三大特性</h4><ul>
<li><p>继承性    </p>
<ul>
<li><p>父元素的css属性可以被子元素继承使用</p>
</li>
<li><p>注意：可以继承的css属性：text-，font-，line-开头的属性都可以继承，color</p>
</li>
<li><p>使用场景：通过body给整个网页设置一个通用的font-</p>
</li>
<li><p>特殊性</p>
<ul>
<li><p>如果是一个a标签，它是不能从父元素继承字体的颜色，因为a标签有自己的默认颜色蓝色，如果要改变a标签的字体颜色，请选择这个a标签，再改color</p>
</li>
<li><p>如果是一个标题标签，它是不能从父元素继承字体的大小的，因为标题标签有自己默认的字体大小，要改变字体大小，请直接选中标题标签设置font-size</p>
<p>​:flower:​ 总结：标签如果有默认的样式的时候，继承过来的css属性就不能起作用</p>
</li>
<li><p>div如果没有设置高度的时候，而且也没有内容，那么它的高度为0，宽度默认继承父元素的宽度</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>层叠性</p>
<ul>
<li>设置相同的css属性的时候，根据远近亲疏让最“亲”的css属性起作用，其它的被覆盖</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li>！important》行内样式》id选择器》类选择器》标签选择器》通配符选择器》继承</li>
<li>虽然！important是一个变数，但是无法继承</li>
</ul>
</li>
<li><p>权重</p>
<ul>
<li>当组合选择器进行使用的时候，我们有一个计算优先级的公式（权重的计算）</li>
<li>（！important的数量，id选择器的数量，类选择器的数量，标签选择器的数量）</li>
<li>浏览器对父元素不敏感</li>
</ul>
<p>​</p>
</li>
</ul>
<h4 id="背景相关的几个属性"><a href="#背景相关的几个属性" class="headerlink" title="背景相关的几个属性"></a>背景相关的几个属性</h4><ul>
<li>背景颜色：background-color</li>
<li>背景图片：background-image</li>
<li>背景是否重复：background-repeat。值有no-repeat/repeat-x/repeat-y/repeat（默认）</li>
<li>背景图片的位置：background-position：center center；水平方向的值：right center  left；垂直方向的值：top center bottom</li>
<li>背景的复合属性：background</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>*{margin：0；padding：0；}</li>
<li>出现图片错位的原因：father的宽度继承自body，会跟着浏览器的窗口变化，son的宽度设定为1000px，当窗口拉动导致father的宽度小于1000的时候，father父元素无法完整显示son了，于是出现了错位的请问</li>
<li>解决方案：给father设置一个最小的宽度：min-width：1000px</li>
<li>背景设置一般图片多大元素宽高就设置多大</li>
</ul>
<h4 id="元素的显示方式"><a href="#元素的显示方式" class="headerlink" title="元素的显示方式"></a>元素的显示方式</h4><ul>
<li>行内元素<ul>
<li>一行里面可以显示多个</li>
<li>无法设置宽高</li>
<li>大小由内容决定</li>
</ul>
</li>
<li>块级元素<ul>
<li>独占一行</li>
<li>可以设置宽高</li>
<li>默认宽度一整行</li>
</ul>
</li>
<li>行内块级元素<ul>
<li>可以设置宽高</li>
<li>一行里面可以显示多个</li>
</ul>
</li>
<li>设置垂直居中：line-height：容器的高度</li>
</ul>
<h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><ul>
<li>a：link——给a标签设置没有被访问过的样式</li>
<li>a：visited——给a标签设置访问过的样式</li>
<li>a：hover——给a标签设置鼠标悬停时的样式</li>
<li>a：active——设置a标签被激活时的样式（被点击时的样式）</li>
<li>要按照一定的顺序编写，否则样式有可能会无法显示</li>
<li>有些锚伪类除了可以作用于a标签上还可以作用在其它标签上<ul>
<li>：link——只能用于a标签</li>
<li>：visited——只能用于a标签</li>
<li>：hover——其它标签也可以使用这个伪类</li>
<li>：active——其它标签也可以使用这个伪类</li>
</ul>
</li>
</ul>
<h4 id="行高（line-height"><a href="#行高（line-height" class="headerlink" title="行高（line-height)"></a>行高（line-height)</h4><ul>
<li>应用：如果行高等于容器的高度，那么元素在父元素中垂直居中</li>
<li>行高的定义：两行文本之间基线的距离就叫做行高</li>
</ul>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ul>
<li>在写一个html页面的时候，其实就相当于在HTML页面叠盒子</li>
<li>万物皆盒子</li>
<li>border<ul>
<li>border-color： 边框的颜色</li>
<li>border-width：边框的宽度</li>
<li>border-style：边框的样式</li>
<li>border-top：设置上边框的粗细样式颜色</li>
<li>border-right：</li>
<li>border-bottom:</li>
<li>border-left:</li>
</ul>
</li>
<li>所有跟外观相关的设置，请不要再使用html来设置了，请使用css来设置，这就是三层分离</li>
<li>border-collapse：设置表格的一个css属性，作用：去除表格中的单元格的间隙</li>
<li>padding：设置内边距的css属性。所谓内容距就是内容与边框之间的距离<ul>
<li>padding：40px——设置内容与边框中间的距离是40px，上右下左四个方向都是40px的距离</li>
<li>padding：40px 80px——设置上内边距，下内边距为40px，左内边距，右内边距是80px</li>
<li>padding：40px 60px 80px——设置上内边距40px，左右内边距的距离是60px，下内边距是80px</li>
<li>padding：40px 60px 80px 100px——以顺时针方向进行设置</li>
</ul>
</li>
<li>​:kiss: padding会改变盒子的大小（跟日常生活中有区别）</li>
<li>计算盒子大小的公式：<ul>
<li>盒子宽：border-left-width+padding-left+width+padding-right+border-right-width</li>
<li>盒子高：border-top-width+padding-top+height+padding-bottom+border-bottom-width</li>
</ul>
</li>
<li>特殊情况下padding不会改变盒子的大小<ul>
<li>当一个大盒子包含一个小盒子，并且大小盒子都是块级元素，而且小盒子的宽度是继承自大盒子的话，那么设置小盒子的padding-left，padding-right不会改变小盒子的大小</li>
</ul>
</li>
<li>margin：设置盒子与盒子之间的距离，外边距</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>body默认带有margin： 8px的属性</li>
<li>p标签带有margin：font-size 0；</li>
<li>h标签默认带有margin-top和margin-bottom</li>
<li>ul标签带有上下的margin以及padding-left</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML&CSS基础知识（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2014/12/13/HMTL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="浏览器与服务器之间的交互过程"><a href="#浏览器与服务器之间的交互过程" class="headerlink" title="浏览器与服务器之间的交互过程"></a>浏览器与服务器之间的交互过程</h5><ol>
<li><p>用户在浏览器的地址栏中输入网站的地址</p>
</li>
<li><p>浏览器将请求报文发送给地址栏中网站的服务器</p>
</li>
<li><p>服务器根据请求报文返回页面数据给浏览器</p>
</li>
<li><p>浏览器得到响应的数据以后将之呈现给用户</p>
</li>
</ol>
<p><a id="more"></a>  ​</p>
<h5 id="请求报文和响应报文——审查元素-》network"><a href="#请求报文和响应报文——审查元素-》network" class="headerlink" title="请求报文和响应报文——审查元素 》network"></a>请求报文和响应报文——审查元素 》network</h5><ol>
<li><p>请求报文：浏览器发送给服务器的</p>
</li>
<li><p>响应报文：服务器返回给浏览器的</p>
</li>
</ol>
<h5 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h5><ul>
<li>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。</li>
<li>浏览器内核（Rendering Engine）：负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>IE：trident；  Safari：webkit；Firefox：gecko；chrome、Opera：blink</li>
</ul>
<h5 id="文件的后缀名"><a href="#文件的后缀名" class="headerlink" title="文件的后缀名"></a>文件的后缀名</h5><ul>
<li>修改文件的后缀名是不会改变内容，只决定打开方式</li>
<li>H系列标签作用：把页面上的文字加上标题的语义</li>
</ul>
<h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul>
<li>http协议<ul>
<li>请求报文</li>
<li>响应报文</li>
<li>URL：协议名、服务器的IP地址、端口号、请求文件的名称</li>
</ul>
</li>
<li>浏览器接受用户操作——浏览器封装HTTP请求——链接服务器：DNS解析——发送请求Request——服务器接收请求——处理请求——返回响应报文——浏览器接收响应报文——渲染页面呈现</li>
<li>如果没有设置端口号那么默认的端口是：80</li>
</ul>
<p>图片是另外请求</p>
<p>继续渲染与请求服务器的图片</p>
<h5 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h5><ul>
<li>img：图片标签</li>
<li>src：标签的属性，设置图片的路径</li>
<li>Alt：如果图片不存在，设置图片的文本信息</li>
<li>title：设置图片的提示信息，当鼠标悬停在图片上方的时候，就会显示提示信息</li>
</ul>
<h5 id="访问有图片的网页时，浏览器和服务器的交互过程"><a href="#访问有图片的网页时，浏览器和服务器的交互过程" class="headerlink" title="访问有图片的网页时，浏览器和服务器的交互过程"></a>访问有图片的网页时，浏览器和服务器的交互过程</h5><ul>
<li>用户在地址栏中输入一个网页的网址，按回车</li>
<li>浏览器就会向这个地址的服务器发送一个请求报文</li>
<li>服务器根据请求报文返回网页的页面数据给浏览器</li>
<li>浏览器解析返回的响应报文，并渲染显示</li>
<li>当浏览器解析到图片的时候，它不知道图片是在哪里的，所以，浏览器会再发送一次请求报文，去请求服务器的那一张图片</li>
<li>然后等待服务器返回图片的响应的时候，浏览器还会继续解析下面的其它内容</li>
</ul>
<h5 id="路径分为两种情况"><a href="#路径分为两种情况" class="headerlink" title="路径分为两种情况"></a>路径分为两种情况</h5><ul>
<li>绝对路径：从盘符开始寻找路径</li>
<li>相对路径：从当前页面开始寻找路径</li>
</ul>
<h5 id="a标签使用的地方"><a href="#a标签使用的地方" class="headerlink" title="a标签使用的地方"></a>a标签使用的地方</h5><ul>
<li>空连接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></li>
<li>去到其它的网页：<code>&lt;a href=&quot;其它的网页.html&quot;&gt;</code></li>
<li>去到其它页面的某一个地方，在跳转的页面进行定位 <code>&lt;a href=&quot;其它的网页.html#id&quot;&gt;</code></li>
<li>去到本页面的某一个地方：<code>&lt;a href=&quot;#id&quot;&gt;</code></li>
<li>下载（不建议）</li>
</ul>
<h5 id="a标签的属性target"><a href="#a标签的属性target" class="headerlink" title="a标签的属性target"></a>a标签的属性target</h5><ul>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_blank&quot;&gt;将会用新的页面打开1.html&lt;/a&gt;</code></li>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_self&quot;&gt;将会在当前的页面打开1.html&lt;/a&gt;</code></li>
<li>base 为页面上所有a标签设置跳转的方式（base标签一般放在title下面，写在head里面）<code>&lt;base target=&quot;_blank&quot;&gt;</code></li>
</ul>
<h5 id="DOCTYPE文档类型"><a href="#DOCTYPE文档类型" class="headerlink" title="DOCTYPE文档类型"></a>DOCTYPE文档类型</h5><ul>
<li>DTD 文档类型定义</li>
<li>html和XHTML规范<ul>
<li>html：3种<ul>
<li>strict</li>
<li>transitional（用的最多）</li>
<li>frameset</li>
</ul>
</li>
<li>XHTML：3种</li>
</ul>
</li>
<li>lang 用来设置当前页面的语言<ul>
<li>设置页面上主要使用语言的类型</li>
<li>将来做SEO的时候在权重上起到一定的作用</li>
<li>用于特殊设备上的设置，eg，盲人设备</li>
</ul>
</li>
</ul>
<h5 id="关于SEO"><a href="#关于SEO" class="headerlink" title="关于SEO"></a>关于SEO</h5><ul>
<li>搜索引擎优化（网站在搜索页面上的排名靠前）<ul>
<li>买排名，不靠谱</li>
<li>将页面做成静态页面（html）</li>
<li>发外链</li>
<li>页面的友好性（规范）：在合适的地方使用合适的标签，合理的使用标签的语义化</li>
</ul>
</li>
<li>讨好搜索引擎<ul>
<li>网络爬虫，搜索引擎机器人：收录Internet上的网站，找到访问量高的，语义化好的网站，最后将这些网站作为搜索的结果呈现给用户观看  任务：就是用来访问页面给页面排序，从而在用户搜索的时候可以有一个先后的排名</li>
</ul>
</li>
<li><p>让网站更靠前的方式：</p>
<ul>
<li>买排名，不靠谱</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h5><ul>
<li>作用：让页面拥有一个属于自己的标题</li>
<li>title中的文本在SEO中占有很大的权重</li>
<li>h1,h2</li>
</ul>
<h5 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h5><ul>
<li>注意：meta中设置的所有的内容在页面都不会显示，</li>
</ul>
<ul>
<li><p>description 可以描述页面，可以用来使用百度程序（网络爬虫）来收录关键信息，以此提高页面的排名</p>
</li>
<li><p>keywords  关键词，可以用来提高页面的关键词的比重的一种方式，:angry:英文的逗号</p>
</li>
<li><p>最多不要超过十个</p>
</li>
<li><p>charset</p>
<ul>
<li><p>字符集：相当于一个字库，在这个字库有很多的文字，每一个文字都有对应的编码</p>
</li>
<li><p>当你设置的网页的编码格式和保存的编码格式不一样的时候，就会发生乱码</p>
</li>
<li><p>gb2312：国际标准，收录了汉字，片假名</p>
</li>
<li><p>gbk：国标扩（扩展版），一个文字2个字节</p>
</li>
<li><p>UTF-8：收录全世界所有的语言中的文字，一个文字3个字节</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul>
<li>无序列表<ul>
<li>ul标签的作用：表示在这里有一个无序的列表</li>
<li>li标签的作用：表示列表的项</li>
<li>注意：ul不能单独出现，ul里面一定要放li，li是一个容器，放什么其他的标签都可以</li>
</ul>
</li>
<li>有序列表<ul>
<li>作用：显示一段有顺序的数据</li>
<li>语义：一组有顺序的数据</li>
</ul>
</li>
<li>自定义列表：dl,dt,dd<ul>
<li>dl标签：写一个自定义列表</li>
<li>dt标签：它代表的就是这儿有一个自定义的列表项</li>
<li>dd标签：代表dt对应的列表项中的具体内容</li>
</ul>
</li>
</ul>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><ul>
<li><p>table标签：表示是一个表格的内容</p>
</li>
<li><p>tr标签：表示是表格中的一行</p>
</li>
<li><p>td标签：表示是表格中的一个单元格</p>
</li>
<li><p>表格的其它标签和属性：</p>
<ul>
<li>表格的属性：<table border="1" cellspacing="" cellpadding=""> <ul>
<li>border：设置表格的边框的宽度 </li>
<li>cellspacing：设置的是表格中的单元格之间的距离</li>
<li>cellpadding：设置的是单元格中的内容与单元格之间的距离</li>
<li>width</li>
<li>height</li>
</ul>
</table></li>
</ul>
</li>
<li><p>表格中的其他标签</p>
<ul>
<li>th标签：设置表头，具体表现的效果是文字加粗，居中</li>
<li>caption标签：设置标题的标题，注意，caption标签应该放在table标签后面</li>
<li>thead标签：设置的是表格的头部信息，一般th的内容都应该放在这里</li>
<li>tbody标签：设置的是表格的主题内容，一般td的内容都放在这里</li>
<li>tfoot标签：设置的是表格的尾部信息，一般是放一些总结性的信息</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h5><ul>
<li><code>&lt;input type=&quot;hidden&quot; value=&quot;&quot;&gt;</code> 学习ajax时候用到</li>
<li><input type="text" value="默认值">：输入框</li>
<li><input type="password">：密码框</li>
<li><input type="hidden" value="隐藏的数据">：隐藏域</li>
<li><input type="radio">：输入框</li>
<li>注意：如果单选按钮要真正做到单选的效果，需要进行分组。通过name属性，可以将多个单选按钮设置为一组</li>
<li>默认选中 checked=”checked”</li>
<li><input type="checkbox" checked="checked" name="hobby">：复选框</li>
<li><input type="button" value="按钮上的文字">：设置一个普通按钮</li>
<li><input type="image" value="图像的路径">：设置一个图像按钮（图像域），按钮的图片需要通过src来进行设置</li>
<li><input type="submit">：提交按钮</li>
<li><input type="reset">：重置按钮</li>
<li>注意：不管是提交还是重置，都要先有一个表单<form></form></li>
<li>下拉框</li>
<li>文本域</li>
</ul>
<p>注意：1. reset如果不设置value值，会有默认值<br>        2.reset、submit等需要和form标签配合使用，否则不会有效果</p>
]]></content>
    </entry>
    
  
  
</search>
