<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[模块化演变历程]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/11/03/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E5%8F%98%E5%8E%86%E5%8F%B2/</url>
      <content type="html"><![CDATA[<p>模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。</p>
<h1 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h1><pre><code>&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt;
</code></pre><p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接<br>口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一<br>个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子<br>如 YUI 库。<br>这种原始的加载方式暴露了一些显而易见的弊端：</p>
<ul>
<li>全局作用域下容易造成变量冲突</li>
<li>文件只能按照 <code>&lt;script&gt;</code> 的书写顺序进行加载</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ul>
<a id="more"></a>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方<br>法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露<br>的接口。<br>    require(“module”);<br>    require(“../file.js”);<br>    exports.doStuff = function() {};<br>    module.exports = someValue;</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>服务器端模块便于重用</li>
<li>NPM 中已经有将近20万个可以使用模块包</li>
<li>简单并容易使用</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li>
<li>不能非阻塞的并行加载多个模块</li>
</ul>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><ul>
<li>服务器端的 Node.js</li>
<li>Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大</li>
<li>modules-webmake，类似Browserify，还不如 Browserify 灵活</li>
<li>wreq，Browserify 的前身</li>
</ul>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>Asynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?,<br>factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到<br>factory 中，对于依赖的模块提前执行，依赖前置。<br>    define(“module”, [“dep1”, “dep2”], function(d1, d2) {<br>    return someExportedValue;<br>    });<br>    require([“module”, “../file”], function(module, file) { /<em> … </em>/ });</p>
<h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>适合在浏览器环境中异步加载模块</li>
<li>可以并行加载多个模块</li>
</ul>
<h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>
<li>不符合通用的模块化思维方式，是一种妥协的实现</li>
</ul>
<h2 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h2><ul>
<li>RequireJS</li>
<li>curl</li>
</ul>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和<br>Node.js 的 Modules 规范保持了很大的兼容性。</p>
<pre><code>define(function(require, exports, module) {
var $ = require(&apos;jquery&apos;);
var Spinning = require(&apos;./spinning&apos;);
exports.doSomething = ...
module.exports = ...
})
</code></pre><h2 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>依赖就近，延迟执行</li>
<li>可以很容易在 Node.js 中运行</li>
</ul>
<h2 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>依赖 SPM 打包，模块的加载逻辑偏重</li>
</ul>
<h2 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h2><ul>
<li>Sea.js</li>
<li>coolie</li>
</ul>
<h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>Universal Module Definition 规范类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的<br>跨平台解决方案。</p>
<h1 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h1><p>EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽<br>量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和<br>AMD 模块，都只能在运行时确定这些东西。<br>    import “jquery”;<br>    export function doStuff() {}<br>    module “localModule” {}</p>
<h2 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>容易进行静态分析</li>
<li>面向未来的 EcmaScript 标准</li>
</ul>
<h2 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>原生浏览器端还没有实现该标准</li>
<li>全新的命令字，新版的 Node.js才支持</li>
</ul>
<h2 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h2><ul>
<li>Babel</li>
</ul>
<h1 id="期望的模块系统"><a href="#期望的模块系统" class="headerlink" title="期望的模块系统"></a>期望的模块系统</h1><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有<br>CSS、图片、字体等资源也需要模块化。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack使用引导]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/10/18/webpack%E4%BD%BF%E7%94%A8%E5%BC%95%E5%AF%BC/</url>
      <content type="html"><![CDATA[<h1 id="webpack使用引导"><a href="#webpack使用引导" class="headerlink" title="webpack使用引导"></a>webpack使用引导</h1><p>因为官网提供的各种配置和启动方法有原生的cli也有配置文件的方式，我们之后的讲解都建立在市面主流使用方法的基础上进行讲解</p>
<h2 id="安装webpack与运行介绍"><a href="#安装webpack与运行介绍" class="headerlink" title="安装webpack与运行介绍"></a>安装webpack与运行介绍</h2><h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><p>Deploy是编译之后的可用于打包的文件，src中的是开发文件</p>
<img src="/mangomao/uploads/webpack/2.png">
<img src="/mangomao/uploads/webpack/3.png">
<a id="more"></a>
<h2 id="引入webpack依赖"><a href="#引入webpack依赖" class="headerlink" title="引入webpack依赖"></a>引入webpack依赖</h2><p>在项目根目录打开命令窗口引入项目依赖，全局安装</p>
<pre><code>npm  install  webpack  -g // 全局安装webpack
</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>在项目根目录创建三个或多个webpack配置文件</p>
<ol>
<li>webpack.base.config.js  //公用的配置放在这里面（可通过插件继承）</li>
<li>webpack.develop.config.js  //开发环境中用到的配置文件</li>
<li>webpack.publish.config.js   //生产环境中用到的配置文件</li>
</ol>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>注意：开发环境的配置和生产环境的配置是不一样的<br>详细的请看这里：<br><a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="external">http://webpack.github.io/docs/configuration.html</a></p>
<pre><code>// 这是最基本的一个配置文件
// 编写配置文件，要有最基本的文件入口和输出文件配置信息等
// 里面还可以加loader和各种插件配置使用
var path = require(&apos;path&apos;);

module.exports = {
    entry:path.resolve(__dirname,&apos;src/js/app.js&apos;),
    output: {
        path: path.resolve(__dirname, &apos;deploy&apos;),
        filename: &apos;bundle.js&apos;,
    },
}
</code></pre><h2 id="运行webpack"><a href="#运行webpack" class="headerlink" title="运行webpack"></a>运行webpack</h2><h3 id="1、通过配置文件运行（通用）"><a href="#1、通过配置文件运行（通用）" class="headerlink" title="1、通过配置文件运行（通用）"></a>1、通过配置文件运行（通用）</h3><ol>
<li><p>在根目录运行webpack的命令，默认会去查找名称为webpack.config.js的文件执行，如果没有就会报配置信息没有配置的错误。</p>
<p> Webpack</p>
</li>
<li><p>这时候我们可以通过运行下面的命令进行配置文件的选择</p>
<p> webpack –-config  webpack.develop.config.js</p>
</li>
</ol>
<h3 id="2、通过cli命令运行（了解）"><a href="#2、通过cli命令运行（了解）" class="headerlink" title="2、通过cli命令运行（了解）"></a>2、通过cli命令运行（了解）</h3><ol>
<li><p>webpack的cli也提供了命令可以进行运行，例如：</p>
<p> Webpack  -watch       // webpack的监视命令，文件发生变化自动编译<br> webpack –entry ./entry.js –output-path dist –output-file bundle.js<br>   //配置文件的启动目录和输出目录<br> webpack 最基本的启动webpack命令<br> webpack -w 提供watch方法，实时进行打包更新<br> webpack -p 对打包后的文件进行压缩<br> webpack -d 提供SourceMaps，方便调试<br> webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤<br> webpack –profile 输出性能数据，可以看到每一步的耗时<br> webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块<br>  webpack –display-error-details 方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。</p>
</li>
<li><p>你可以运行webpack  -h查看webpack的其他命令，自行了解，或者通过英文官网了解webpack Cli部分</p>
</li>
</ol>
<h3 id="3、作为nodejs的api运行"><a href="#3、作为nodejs的api运行" class="headerlink" title="3、作为nodejs的api运行"></a>3、作为nodejs的api运行</h3><p>var webpack = require(‘webpack’);<br>webpack({<br>//configuration<br>}, function(err, stats){});</p>
<p>4、注意：但是我们基本上不用这种直接提供的命令，因为我们需要手动的敲打很多字母，我们现在开发通用的方法都是使用配置文件的方式运行。</p>
<h1 id="把运行命令配置到npm的script中"><a href="#把运行命令配置到npm的script中" class="headerlink" title="把运行命令配置到npm的script中"></a>把运行命令配置到npm的script中</h1><h2 id="为什么要用npm的script"><a href="#为什么要用npm的script" class="headerlink" title="为什么要用npm的script"></a>为什么要用npm的script</h2><ol>
<li>npm 是一个非常好用的用来编译的指令，通过 npm 你可以不用去担心项目中使用了什么技术，你只要调用这个指令就可以了，只要你在 package.json 中设置 scripts 的值就可以了。</li>
<li>真正开发的时候你的webpack的命令会敲很长，因为有很多命令需要设置，即便你用了配置文件的方式，但一些–colors  –hot这些命令是没法在配置文件中配置的。比如：<br>webpack-dev-server –devtool eval –progress –colors –hot –content-base build<br>所以你不可能每次都敲这么长，因而我们就把这一大串配置到npm中</li>
</ol>
<h2 id="Npm的script的使用"><a href="#Npm的script的使用" class="headerlink" title="Npm的script的使用"></a>Npm的script的使用</h2><ol>
<li>你首先需要安装webpack，这时候不全局安装<br>npm i webpack –save</li>
<li><p>配置npm的package.json文件中<br>“scripts”: {<br>   “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1”,<br>   “develop”: “webpack –config webpack.develop.config.js”,<br>   “publish”: “webpack –config webpack.publish.config.js”<br>},</p>
</li>
<li><p>在根目录打开的命令窗口运行<br>npm  run  develop</p>
</li>
</ol>
<h1 id="为发布目录启动服务"><a href="#为发布目录启动服务" class="headerlink" title="为发布目录启动服务"></a>为发布目录启动服务</h1><p>如果需要一直输入 npm run develop 确实是一件非常无聊的事情，幸运的是，我们可以把让他安静的运行，让我们设置 webpack-dev-server<br>除了提供模块打包功能，Webpack还提供了一个基于Node.js Express框架的开发服务器，它是一个静态资源Web服务器，对于简单静态页面或者仅依赖于独立服务的前端页面，都可以直接使用这个开发服务器进行开 发。在开发过程中，开发服务器会监听每一个文件的变化，进行实时打包，并且可以推送通知前端页面代码发生了变化，从而可以实现页面的自动刷新。</p>
<h2 id="1、安装webpack-dev-server"><a href="#1、安装webpack-dev-server" class="headerlink" title="1、安装webpack-dev-server"></a>1、安装webpack-dev-server</h2><p>npm   i   webpack-dev-server   –save-dev</p>
<h2 id="2、调整npm的package-json-scripts-部分中开发命令的配置"><a href="#2、调整npm的package-json-scripts-部分中开发命令的配置" class="headerlink" title="2、调整npm的package.json scripts 部分中开发命令的配置"></a>2、调整npm的package.json scripts 部分中开发命令的配置</h2><p>{<br> “scripts”: {<br> “develop”: “webpack-dev-server  –config webpack.develop.config.js –devtool eval –progress –colors –hot –content-base src”,<br>“publish”: “webpack –config webpack.publish.config.js”,<br>“watch”: “webpack –config webpack.develop.config.js –watch –hot”<br> }<br>}<br>注释：<br>    webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器<br>    –devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号<br>    –progress - 显示合并代码进度<br>    –colors – hot，命令行中显示颜色！<br>    –content-base  指向设置的输出目录//这点一定是我们的发布目录</p>
<h2 id="3、访问-http-localhost-8080-你会看到效果。"><a href="#3、访问-http-localhost-8080-你会看到效果。" class="headerlink" title="3、访问 http://localhost:8080 你会看到效果。"></a>3、访问 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 你会看到效果。</h2><p>总的来说，当你运行 npm run develop 的时候，会启动一个 Web 服务器，然后监听文件修改，然后自动重新合并你的代码。真的非常简洁！</p>
<h2 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h2><ul>
<li>用webpack-dev-server生成bundle.js文件是在内存中的，并没有实际生成</li>
<li>如果引用的文件夹中已经有bundle.js就不会自动刷新了，你需要先把bundle.js文件手动删除</li>
<li>用webstorm的注意了，因为他是自动保存的，所以可能识别的比较慢，你需要手动的ctrl+s一下</li>
</ul>
<h1 id="浏览器自动刷新"><a href="#浏览器自动刷新" class="headerlink" title="浏览器自动刷新"></a>浏览器自动刷新</h1><p>现在可以启动一个服务并监听变化了，但是浏览器你还需要手动刷新一下，我们其实是可以通过下面的这个方法让他自动刷新的。</p>
<p>2.4.1修改webpack.develop.config.js的配置<br>修改entry部分如下图：<br>var path = require(‘path’);</p>
<p>module.exports = {<br>    entry:[<br>        ‘webpack/hot/dev-server’,<br>        ‘webpack-dev-server/client?<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>‘,<br>        path.resolve(<strong>dirname,’src/js/app.js’)<br>    ],<br>    output: {<br>        path: path.resolve(</strong>dirname, ‘deploy’),<br>        filename: ‘bundle.js’,<br>    },<br>    module: {<br>        loaders: [<br>            { test: /.css$/, loader: “style!css” }<br>        ]<br>    }<br>}</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webpack简介]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/10/16/webpack%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h1><p>CommonJS和AMD是用于JavaScript模块管理的两大规范，前者定义的是模块的同步加载，主要用于NodeJS；而后者则是异步加载，通过requirejs等工具适用于前端。随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者 自身就会发布到npm平台。因此，让前端项目更方便的使用npm上的资源成为一大需求。<br>web开发中常用到的静态资源主要有JavaScript、CSS、图片、Jade等文件，webpack中将静态资源文件称之为模块。 webpack是一个module bundler(模块打包工具)，其可以兼容多种js书写规范，且可以处理模块间的依赖关系，具有更强大的js模块化的功能。Webpack对它们进行统 一的管理以及打包发布，其官方主页用下面这张图来说明Webpack的作用</p>
<img src="/mangomao/uploads/webpack/1.png">
<a id="more"></a>
<h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><p>官网：<a href="http://webpack.github.io/docs/" target="_blank" rel="external">http://webpack.github.io/docs/</a>  先过这三个文档文档<br>Webpack-handlebook: <a href="http://zhaoda.net/webpack-handbook/" target="_blank" rel="external">http://zhaoda.net/webpack-handbook/</a><br>Gitbook: <a href="http://fakefish.github.io/react-webpack-cookbook/index.html" target="_blank" rel="external">http://fakefish.github.io/react-webpack-cookbook/index.html</a><br>Github上的几十个example看一遍<br>参考网站：<br><a href="https://segmentfault.com/a/1190000003970448" target="_blank" rel="external">https://segmentfault.com/a/1190000003970448</a><br><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">https://github.com/ruanyf/webpack-demos</a><br><a href="https://segmentfault.com/a/1190000002551952" target="_blank" rel="external">https://segmentfault.com/a/1190000002551952</a><br><a href="http://blog.csdn.net/yczz/article/details/49250623" target="_blank" rel="external">http://blog.csdn.net/yczz/article/details/49250623</a><br><a href="https://github.com/petehunt/webpack-howto#8-optimizing-common-code" target="_blank" rel="external">https://github.com/petehunt/webpack-howto#8-optimizing-common-code</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651220238&amp;idx=1&amp;sn=ebdba528f199e10f6b273c3a6fd04650&amp;scene=0&amp;key=b28b03434249256b7847bfdf62609ae5dc60fe6644c4c53f8f8e392425069ed2d9fa147c8c66f9d719456241c3a687ba&amp;ascene=14&amp;uin=MjYzMjMwMzE4MA%3D%3D&amp;devicetype=android-21&amp;version=26031031&amp;nettype=WIFI&amp;pass_ticket=3wAH%2BijJnBbvbS8rfC%2FF5Sv78DZDco29Ejqjt96dzxTLB72USiOBN69mnq9DFTFy" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651220238&amp;idx=1&amp;sn=ebdba528f199e10f6b273c3a6fd04650&amp;scene=0&amp;key=b28b03434249256b7847bfdf62609ae5dc60fe6644c4c53f8f8e392425069ed2d9fa147c8c66f9d719456241c3a687ba&amp;ascene=14&amp;uin=MjYzMjMwMzE4MA%3D%3D&amp;devicetype=android-21&amp;version=26031031&amp;nettype=WIFI&amp;pass_ticket=3wAH%2BijJnBbvbS8rfC%2FF5Sv78DZDco29Ejqjt96dzxTLB72USiOBN69mnq9DFTFy</a></p>
<h1 id="为什么使用-webpack"><a href="#为什么使用-webpack" class="headerlink" title="为什么使用 webpack?"></a>为什么使用 webpack?</h1><ol>
<li>对 CommonJS 、 AMD 、ES6的语法做了兼容</li>
<li>对js、css、图片等资源文件都支持打包</li>
<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li>
<li>有独立的配置文件webpack.config.js</li>
<li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li>
<li>支持 SourceUrls 和 SourceMaps，易于调试</li>
<li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</li>
<li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是响应式开发]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/05/20/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="什么是响应式开发"><a href="#什么是响应式开发" class="headerlink" title="什么是响应式开发"></a>什么是响应式开发</h1><p>在移动互联日益成熟的时候，我们在桌面浏览器上开发的网页已经无法满足移动设备的阅读。<br>通常的做法是针对移动端单独做一套特定的版本。<br>但是如果终端越来越多那么你需要开发的版本就会越来越多（大屏移动设备普及）。<br>那么Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端。 </p>
<a id="more"></a>
<h1 id="响应式开发的原理"><a href="#响应式开发的原理" class="headerlink" title="响应式开发的原理"></a>响应式开发的原理</h1><p>通过查询screen的宽度来指定某个宽度区间的网页布局。<br>超小屏幕（移动设备）    768px以下<br>小屏设备    768px-992px<br>中等屏幕    992px-1200pxCSS3中的Media Query（媒介查询）<br>宽屏设备    1200px以上 </p>
<h1 id="响应式开发的前景"><a href="#响应式开发的前景" class="headerlink" title="响应式开发的前景"></a>响应式开发的前景</h1><p>现在的移动设备屏幕越来越大。<br>越来越多的设计师也采用了这种设计。<br>在新建站的一些网站现在普遍采用的响应式开发。<br>那么在前端开发当中也是一项必备的技能。</p>
<h1 id="响应式开发和移动web开发的区别"><a href="#响应式开发和移动web开发的区别" class="headerlink" title="响应式开发和移动web开发的区别"></a>响应式开发和移动web开发的区别</h1><img src="/mangomao/uploads/bootstrap/1.png">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写移动项目时遇到的问题(二)]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/05/19/%E5%86%99%E7%A7%BB%E5%8A%A8%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="使用过渡和改变注意问题"><a href="#使用过渡和改变注意问题" class="headerlink" title="使用过渡和改变注意问题"></a>使用过渡和改变注意问题</h1><p>在移动端为了兼容老版本的一些webkit浏览时在css中或者js中一定要做兼容处理。<br>Css中的处理方法是加上-webkit-前缀和一个不加的。<br>Js中处理方法是style设置的时候需要设置一个webkit前缀的属性和一个不加的。</p>
<a id="more"></a>
<h1 id="两栏其中一栏宽度自适应"><a href="#两栏其中一栏宽度自适应" class="headerlink" title="两栏其中一栏宽度自适应"></a>两栏其中一栏宽度自适应</h1><p>我们首先知道文本环绕的的概念：<br><img src="/mangomao/uploads/mobile/2.png"></p>
<p>那么当文本在另一个容器当中，容器是overflow：hidden的时候。那么这个时候这个盒子就变成了一个绝缘的盒子，不去影响任何外部的元素并且内容使用剩余的宽度。<br>这样也可是做一个<strong>自适应的两栏布局方式</strong>。</p>
<h1 id="按钮问题"><a href="#按钮问题" class="headerlink" title="按钮问题"></a>按钮问题</h1><p>按钮设置的是  40*44的大小  但是内容只有20px为什么要这么设置呢？<br>在移动端如果按钮太小 触发起来相对来说比较困难，用户体验非常不好。那么在设置按钮的时候需要设置的更大一点。<br>注意不能使用margin，应为a标签触发不了。</p>
<h1 id="移动端事件原理"><a href="#移动端事件原理" class="headerlink" title="移动端事件原理"></a>移动端事件原理</h1><p>在移动端通常  tap swipe 等事件的封装原理</p>
<h2 id="Tap："><a href="#Tap：" class="headerlink" title="Tap："></a>Tap：</h2><p>由于在移动端click会有300ms左右的延时，为了响应速度更快移动端框架一般会封装一个加tap的事件，原理：利用touch事件当没有滑动过并且响应时间在一定的时间内（比click快）那么这样的一个过程就是一个tap事件。</p>
<h2 id="Swipe："><a href="#Swipe：" class="headerlink" title="Swipe："></a>Swipe：</h2><p>在移动端有手势事件，也是一些移动端框架封装出来的那么这种事件也是touch事件开始的位置和结束的位置来判断手势的情况。是向下滑还是向右滑，是向下滑还是向上滑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二、移动端事件]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/05/18/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="Touch事件"><a href="#Touch事件" class="headerlink" title="Touch事件"></a>Touch事件</h1><h2 id="ouchstart：当手指触碰屏幕时候触发。"><a href="#ouchstart：当手指触碰屏幕时候触发。" class="headerlink" title="ouchstart：当手指触碰屏幕时候触发。"></a>ouchstart：当手指触碰屏幕时候触发。</h2><p>绑定事件的方法：</p>
<pre><code>dom.addEventListener(&apos;touchstart&apos;,function(e){});
</code></pre><p>事件返回的e对象包含那些移动端特有的属性：<br>targetTouches 目标元素的所有当前触摸<br>changedTouches 页面上最新更改的所有触摸<br>touches 页面上的所有触摸</p>
<h2 id="touchmove：当手指在屏幕上滑动时连续触发。"><a href="#touchmove：当手指在屏幕上滑动时连续触发。" class="headerlink" title="touchmove：当手指在屏幕上滑动时连续触发。"></a>touchmove：当手指在屏幕上滑动时连续触发。</h2><p>绑定事件的方法：</p>
<pre><code>dom.addEventListener(&apos;touchmove&apos;,function(e){});
</code></pre><p>事件返回的e对象包含那些移动端特有的属性：<br>originalEvent  是jquery 封装的事件。<br>targetTouches 目标元素的所有当前触摸<br>changedTouches 页面上最新更改的所有触摸<br>touches 页面上的所有触摸</p>
<h2 id="touchend：当手指离开屏幕时触发。"><a href="#touchend：当手指离开屏幕时触发。" class="headerlink" title="touchend：当手指离开屏幕时触发。"></a>touchend：当手指离开屏幕时触发。</h2><p>绑定事件的方法：<br>    dom.addEventListener(‘touchend’,function(e){});</p>
<p>事件返回的e对象包含那些移动端特有的属性：<br>changedTouches 页面上最新更改的所有触摸 </p>
<h2 id="touchcancel-系统停止跟踪触摸时候会触发。"><a href="#touchcancel-系统停止跟踪触摸时候会触发。" class="headerlink" title="touchcancel:系统停止跟踪触摸时候会触发。"></a>touchcancel:系统停止跟踪触摸时候会触发。</h2><p>这个事件不会经常使用，了解即可。</p>
<h2 id="注意：在touchend事件的时候event只会记录changedtouches"><a href="#注意：在touchend事件的时候event只会记录changedtouches" class="headerlink" title="注意：在touchend事件的时候event只会记录changedtouches"></a>注意：在touchend事件的时候event只会记录changedtouches</h2><p>clientX:触摸目标在视口中的X坐标。<br>clientY:触摸目标在视口中的Y坐标。<br>pageX：触摸目标在页面中的x坐标。<br>pageY：触摸目标在页面中的y坐标。<br>screenX:触摸目标在屏幕中的x坐标。<br>screenY:触摸目标在屏幕中的y坐标。</p>
<h1 id="移动端的滑动效果"><a href="#移动端的滑动效果" class="headerlink" title="移动端的滑动效果"></a>移动端的滑动效果</h1><p>在移动端特有的事件touch中，<br>包含了  touchstart，touchmove，touchend三个事件，<br>首先：<br>我们可以通过touchstart事件中返回的event对象中的第一个触摸点信息中的client坐标，<br>然后：<br>我们再通过监听touchmove事件的时候获取到滑动的时候的触摸点，再获取event对象中返回的client坐标，这样就可以计算滑动的时候改变的距离。<br>同时改变当前元素的translate就可以。<br>最后：<br>在touchend的时候利用记录下当前元素的定位。</p>
<blockquote>
<p>注意的是：在移动端是利用transform来做定位。<br>滑动的时候改变距离的方向问题。</p>
</blockquote>
<h1 id="过渡和动画结束事件"><a href="#过渡和动画结束事件" class="headerlink" title="过渡和动画结束事件"></a>过渡和动画结束事件</h1><h2 id="transitionEnd-过渡结束后触发。"><a href="#transitionEnd-过渡结束后触发。" class="headerlink" title="transitionEnd:过渡结束后触发。"></a>transitionEnd:过渡结束后触发。</h2><p>绑定事件的方法：</p>
<pre><code>dom.addEventListener(&apos;webkitTransitionEnd&apos;,function(e){ });
dom.addEventListener(&apos;transitionEnd&apos;,function(e){ });
</code></pre><p>在这里要注意的是：为了兼容浏览器在绑定事件的时候需要同时绑定一个带webkit前缀的事件和不带的这样达到兼容主流浏览器。<br>还有：给目标元素绑定事件后，<strong>每一次过渡结束都会触发transitionEnd事件</strong>。</p>
<h2 id="animationEnd-动画结束后触发。"><a href="#animationEnd-动画结束后触发。" class="headerlink" title="animationEnd:动画结束后触发。"></a>animationEnd:动画结束后触发。</h2><p>绑定事件的方法：</p>
<pre><code>dom.addEventListener(&apos;webkitAnimationEnd&apos;,function(e){ });
dom.addEventListener(&apos;animationEnd&apos;,function(e){ });
</code></pre><h1 id="Gesture-事件（不常用）"><a href="#Gesture-事件（不常用）" class="headerlink" title="Gesture 事件（不常用）"></a>Gesture 事件（不常用）</h1><h2 id="gesturestart"><a href="#gesturestart" class="headerlink" title="gesturestart"></a>gesturestart</h2><p>当一个手指触摸屏幕之后，第二个手指再触摸屏幕时触发。</p>
<h2 id="gesturechange"><a href="#gesturechange" class="headerlink" title="gesturechange"></a>gesturechange</h2><p>当上面的事件触发后立即触发。</p>
<h2 id="gestureend"><a href="#gestureend" class="headerlink" title="gestureend"></a>gestureend</h2><p>第二根手指离开屏幕时触发，之后将不会再次触发gesturechange。</p>
<p>在event当中会返回另外两个参数<br>scale 根据两个手指的滑动距离计算的缩放比例 初始1<br>rotation根据两个手指的滑动距离计算的旋转角度 初始 0</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（4）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%885%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>面向对象——原型链、作用域、函数（都是以函数为中心）</p>
<h4 id="一、函数的四种调用模式"><a href="#一、函数的四种调用模式" class="headerlink" title="一、函数的四种调用模式"></a>一、函数的四种调用模式</h4><blockquote>
<ul>
<li><p>函数有下列调用模式</p>
<ul>
<li>函数调用模式</li>
<li>方法模式</li>
<li>构造器模式</li>
<li>上下文模式<a id="more"></a>
</li>
</ul>
</li>
<li><p>函数的定义方式</p>
<ul>
<li>声明式</li>
<li>表达式式</li>
<li>Function</li>
</ul>
</li>
<li><p>单独独立调用的就是函数</p>
<ul>
<li>函数名( 参数 )</li>
<li>表示全局对象</li>
<li>任何自调用函数都是函数模式</li>
</ul>
</li>
<li><p>方法调用 模式   method</p>
<ul>
<li>区分<ul>
<li>方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.</li>
</ul>
</li>
<li>对象.方法( 参数 )<ul>
<li>this 表示引导方法的对象</li>
</ul>
</li>
</ul>
</li>
<li>方法调用一定要有宿主对象，方法一定是某个对象的方法，对象可以是任何对象（非基本数据类型）</li>
<li>函数也是对象，也可以调用方法</li>
<li>方法调用, 常常称为静态方法<pre><code>* o.func();
* fn.func();
* arr.func();
* arr[n].func();
</code></pre></li>
</ul>
</blockquote>
<h4 id="二、错题"><a href="#二、错题" class="headerlink" title="二、错题"></a>二、错题</h4><pre><code>var length = 10;
function fn() {
    console.log( this.length );
}
var obj = {
    length: 5,
    method: function ( fn ) {
        fn();
        arguments[ 0 ]();
    }
};
obj.method( fn, 1 );
</code></pre><h4 id="三、构造器模式-构造函数模式-构造方法模式"><a href="#三、构造器模式-构造函数模式-构造方法模式" class="headerlink" title="三、构造器模式(构造函数模式, 构造方法模式)"></a>三、构造器模式(构造函数模式, 构造方法模式)</h4><blockquote>
<ul>
<li>constructor</li>
<li>区分<ul>
<li>使用 new 关键字引导</li>
</ul>
</li>
<li>执行步骤<ul>
<li>var p = new Person();</li>
<li>new 是一个运算符, 专门用来申请创建对象(本质上就是申请一段内存), 创建出来的对象传递给构造函数的 this,利用构造函数对其初始化<br>new以后就创建了对象类似于{}，但是原型结构不同，其类型由构造函数决定</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>   function Person () {
       this.name = &apos;jim&apos;;
       this.age = 19;
       this.gender = &apos;male&apos;;
   }

* 理解:当new了一个新对象之后,this就等于这个新创建的对象,this.age等成员就相当于给新创建的对象加成员，完成赋值，依赖的原理是对象动态添加成员的特性(new 的过程会去创建一个空的对象，将这个新创建的空对象赋值给Person函数中的this，此时我们就可以通过this来访问这个新对象了，开始执行Person函数内部的代码；this现在是新创建的对象，所以我们给新创建的对象添加name属性为jack，age属性为20；如果Person函数中没有写return语句，那么默认返回新创建的对象this）
</code></pre><p>交给构造函数初始化</p>
<ul>
<li>var one={}；和构造器的原型不能</li>
<li><p>返回值</p>
<ul>
<li>如果不写 return 语句, 那么 构造函数 默认返回 this</li>
<li>如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. </li>
<li><p>如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this</p>
</li>
<li><p>如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的<br>function Person(){return;this.age=18}</p>
</li>
</ul>
</li>
</ul>
<h4 id="四、关于构造函数结合性的一个小结"><a href="#四、关于构造函数结合性的一个小结" class="headerlink" title="四、关于构造函数结合性的一个小结"></a>四、关于构造函数结合性的一个小结</h4><blockquote>
<ul>
<li>如果构造函数没有参数, 可以省略 圆括号<ul>
<li>var p = new Person;</li>
</ul>
</li>
<li>如果希望创建对象并直接调用其方法<ul>
<li>( new Person () ).sayHello()</li>
<li>可以省略调整结合性的圆括号</li>
<li>new Person().sayHello()</li>
<li>如果想要省略构造函数的圆括号, 就必须添加结合性的圆括号</li>
<li>(new Person).sayHello()</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="五、上下文调用模式"><a href="#五、上下文调用模式" class="headerlink" title="五、上下文调用模式"></a>五、上下文调用模式</h4><blockquote>
<ul>
<li>就是 环境调用模式 =&gt; 在不同环境下的不同调用模式<br>*简单说就是统一一种格式, 可以实现 函数模式与方法模式</li>
</ul>
</blockquote>
<ul>
<li>语法(区分)<ul>
<li>call 形式<ul>
<li>函数名.call( … )</li>
</ul>
</li>
<li>apply 形式<ul>
<li>函数名.apply( … )</li>
</ul>
</li>
<li>这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li><p>存在上下文调用的目的就是为了实现借用方法</p>
<p> function foo () {</p>
<pre><code>console.log( this );
</code></pre><p> }<br> var o = { name: ‘jim’ };<br> foo();<br> o.func = foo;<br> o.func();<br> // 如果需要让函数以函数的形式调用, 可以使用<br> foo.apply( null ) 或 foo.apply()<br> // 如果希望他是方法调用模式, 注意需要提供一个宿主对象<br> foo.apply( o )该方式调用，不会污染宿主对象，不必要宿主对象，必须包含该方法</p>
</li>
</ul>
</li>
<li><p>带有参数的函数如何实现上下文调用</p>
<pre><code>function foo ( num1, num2 ) {
    console.log( this );
    return num1 + num2;
} 
// 函数调用模式
var res1 = foo( 123, 567 );
// 方法调用
var o = { name: &apos;jim&apos; };
o.func = foo;
var res2 = o.func( 123, 567 );
</code></pre><ul>
<li>使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象</li>
<li>如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个</li>
<li><p>数组参数, 将函数的参数依次放在数组中. </p>
<p> 例如: 函数模式        foo( 123, 567 );</p>
<pre><code>apply         foo.apply( null, [ 123, 567 ] )
</code></pre></li>
<li><p>如果有一个函数调用: func( ‘张三’, 19, ‘男’ ), 将其修改成 apply 模式<br> func.apply( null, [ ‘张三’, 19, ‘男’] )</p>
<p> 方法模式:           o.func( 123, 567 )<br> apply               foo.apply( o, [ 123, 567 ] )</p>
</li>
<li><p>函数中的this到底是什么</p>
</li>
<li>函数中this是由调用函数的模式来决定的<ul>
<li>函数调用模式=》this：window</li>
<li>方法调用模式=》this：调用方法的对象</li>
<li>构造器调用模式=》this：new出来的那个对象</li>
<li>上下文调用模式 this：apply或call方法的第一个参数，如果是null，this就是window，如果第一个参数是对象，this就是这个对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="六、call-调用"><a href="#六、call-调用" class="headerlink" title="六、call 调用"></a>六、call 调用</h4><ul>
<li>在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂</li>
<li><p>所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组<br>赋值赋的是函数体，不包含宿主对象</p>
<p> foo( 123, 567 );<br> foo.apply( null, [ 123, 567 ] );<br> foo.call( null, 123, 567 );</p>
</li>
</ul>
<h4 id="七、借用构造方法实现继承"><a href="#七、借用构造方法实现继承" class="headerlink" title="七、借用构造方法实现继承"></a>七、借用构造方法实现继承</h4><pre><code>function Person ( name, age, gender ) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
function Student ( name, age, gender, course ) {
    Person.call( this, name, age, gender );
    this.course = course;
}
var p = new Student ( &apos;jim&apos;, 19, &apos;male&apos;, &apos;前端&apos; );
</code></pre><ol>
<li><p>函数的 bind 方法</p>
<ul>
<li><p>bind 就是 绑定</p>
<ul>
<li>就是让函数绑定对象的一种用法</li>
<li>函数本身就是可以调用, 但是其如果想要作为方法调用, 就必须传入宿主对象, 并且使用 call 或 apply 形式</li>
<li>但是 bind 使得我的函数可以与某一个对象绑定起来, 那么在调用函数的时候, 就好像是该对象在调用方法</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>函数.bind( 对象 )   </li>
<li>返回一个函数 foo</li>
<li>那么调用 返回的函数 foo, 就好像 对象在调用 该方法一样</li>
</ul>
</li>
</ul>
</li>
<li><p>Object.prototype 的成员<br>1) constructor<br>2) hasOwnProperty 判断该属性是否为自己提供<br>3) propertyIsEnumerable 判断属性是否可以枚举<br>4) isPrototypeOf    判断是否为原型对象<br>5) toString, toLocaleString, valueOf</p>
</li>
<li><p>包装对象<br>字符串 string 是基本类型, 理论上讲不应该包含方法<br>charAt, substr, slice, …</p>
<p>在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型</p>
<p>Number<br>String<br>Boolean</p>
<p>在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候<br>自动的将基本类型转换成对象类型.</p>
<p>“abc”.charAt( 1 )</p>
<p>“abc” -&gt; new String( “abc” )<br>s.charAt( 1 ) 返回结果<br>s 就被销毁</p>
<p>当   基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法.<br>方法执行结束后, 这个对象就被立刻回收</p>
<p>在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字<br>就会自动转换成对应的包装类型</p>
</li>
<li><p>getter 与 setter 的语法糖</p>
<p>语法糖: 为了方便开发而给出的语法结构</p>
<p>var o = (function () {</p>
<pre><code>var num = 123;
return {
    get_num: function () {
        return num;
    },
    set_num: function ( v ) {
        num = v;
    }
};
</code></pre><p>})();</p>
<p>// 获得数据<br>o.get_num();            =&gt; o.num 形式</p>
<p>// 设置<br>o.set_num( 456 );       =&gt; o.num = 456 形式</p>
<p>var o = (function () {</p>
<pre><code>var num = 123;
return {

    // get 名字 () { 逻辑体 }
    get num () {
        return num;
    }

    // set 名字 ( v ) { 逻辑体 }
    set num ( v ) {
        num = v;
    }
};
</code></pre><p>})();</p>
</li>
<li><p>ES5 中引入的部分数组方法<br>1&gt; forEach<br>2&gt; map<br>3&gt; filter<br>4&gt; some<br>5&gt; every<br>6&gt; indexOf<br>7&gt; lastIndexOf</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（4）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%884%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><ul>
<li>闭包的概念<ul>
<li>闭包就是封闭，包裹的意思，在js中就是指函数</li>
<li>函数内的空间就是一个封闭的包裹的范围</li>
<li>因此闭包就是函数所构成的一个外部无法直接访问的区域<a id="more"></a></li>
</ul>
</li>
<li>在js中，什么是闭包<ul>
<li>函数内有个内存空间，函数运行要分配内存空间</li>
<li>在js中函数是一个具有变量作用域隔离特性的一个内存结构，即为一个闭包。正确的说法，定义一个函数，可以构成一个闭包</li>
</ul>
</li>
<li>闭包的本质<ul>
<li>利用作用域访问规则的不可逆性，构成一个单向的空间</li>
</ul>
</li>
<li>要解决的问题<ul>
<li>在js中闭包要解决的问题就是间接的访问到这个被隔离的数据（不能直接访问，就间接访问）</li>
<li>函数运行内存模型</li>
</ul>
</li>
</ul>
<h4 id="二、在外部访问num中的数据"><a href="#二、在外部访问num中的数据" class="headerlink" title="二、在外部访问num中的数据"></a>二、在外部访问num中的数据</h4><blockquote>
<ul>
<li>函数是基本的对象类型，在js中与普通对的对象具有一样的意义<ul>
<li>函数可以作为变量一样赋值</li>
<li>作为参数一样传递</li>
<li>作为返回值使用</li>
</ul>
</li>
<li>闭包的间接访问<ul>
<li>使用return数据不能直接访问原来的数据，那么可以考虑利用函数的返回访问原始数据</li>
<li>foo只调用一次，就可以创建一个原始数据，但是返回的函数可以重复调用，每调用一次就是在获取闭包中的数据的值</li>
</ul>
</li>
<li>闭包代码的基本结构</li>
</ul>
</blockquote>
<pre><code>function foo(){
   var num=123;
   return function(){
       return num;
    }
 }
</code></pre><blockquote>
<ul>
<li>如何返回闭包中的数据<ul>
<li>返回单个数据：只要返回一个函数（这个函数返回我们需要的那个数据），就可以了</li>
<li>返回多个数据：需要返回一个对象（这个对象拥有多个方法，每一个方法返回一个需要的数据）来返回多个数据</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="三、利用闭包——实现私有数据"><a href="#三、利用闭包——实现私有数据" class="headerlink" title="三、利用闭包——实现私有数据"></a>三、利用闭包——实现私有数据</h4><blockquote>
<ul>
<li>函数允许返回一个对象，那么该对象可以提供数据访问方法，但是数据存储在闭包中，达到私有的目的</li>
</ul>
</blockquote>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><ul>
<li>构造函数里面的return 有什么用<ul>
<li>构造函数一般是不用写return的，不写return默认返回new出来的哪一个新对象</li>
<li>现在就是在构造函数里写了return，就不会返回new出来的那一个新对象了，而是返回return后面的对象（不包含基本类型的内容，如果return后面的内容是基本类型的数据，无视该return，直接返回new出来的那一个对象）</li>
</ul>
</li>
</ul>
<pre><code>function Person(name,age,gender){
     var newObj=this;
     newObj.name=name;
     newObj.age=age;
     newObj.gender=gender;
     return{
         get_name:function(){
             console.log(this);
             return this.name;

         },
         set_name:function(val){
             if(typeof val===&apos;string&apos; &amp;&amp; val.length&lt;=5){
                 newObj.name=val;
             }
         },
         get_age:function(){
             return newObj.age;
         },
         set_age:function(val){
             if(typeof val===&apos;number&apos; &amp;&amp; val&gt;=0){
                 newObj.age=val;
             }
         },
         get_gender:function(){
             return newObj.gender;
         },
         set_gender:function(val){
             if(val===&apos;男&apos;||val===&apos;女&apos;){
                 newObj.gender=val;
             }
         }
     } }
</code></pre><h4 id="四、闭包的核心"><a href="#四、闭包的核心" class="headerlink" title="四、闭包的核心"></a>四、闭包的核心</h4><blockquote>
<ul>
<li>闭包实现各种特性，其根本的核心内容只有两个<ul>
<li>带有私有数据的函数</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>function foo（）{
     var num=123；
     return function（）{
        //可以访问num
    }
}
var func=foo();
//称func是一个带有私有数据的函数
//称func带有缓存
</code></pre><blockquote>
<ul>
<li>带有私有数据的对象</li>
</ul>
</blockquote>
<h4 id="五、闭包的应用"><a href="#五、闭包的应用" class="headerlink" title="五、闭包的应用"></a>五、闭包的应用</h4><blockquote>
<ul>
<li>沙箱模式<ul>
<li>沙箱就是一个隔离的执行环境<ul>
<li>在js中什么情况需要使用沙箱</li>
<li>function Person（）{}</li>
<li>定义变量越多，出现冲突的可能性越大</li>
</ul>
</li>
<li>就是一个自调用的函数，将数据放到自调用的函数中，此时就不会发生全局作用域的污染了，而且我们还会在自调用的函数中返回一个接口</li>
</ul>
</li>
<li>事件追加——模拟onload事件的追加与移除<ul>
<li>注意——删除以后 arr.length 就发生变化了</li>
<li>console.log( {} == {} );  比较他们的引用，每次解析的都不同</li>
<li>setInterval(function(){},100);其实是创建了很多次函数</li>
<li>建议 function f(){};setInterval(f,100);</li>
</ul>
</li>
<li>cache缓存对象——搭建基本结构<ul>
<li>闭包的缺点：数据会一直占据内存</li>
<li>cache对象，可以使用cache[key]=value存储数据，cache[key]获得数据，当cache里面的数据达到1024条，将最早放进去的数据溢出</li>
<li>cache={}可以存取数据，但是不能限定数据的长度<br>如果需要限定数据，就是在加入数据的时候判断，是否已超过尺寸，如果是，则移除，如果不是，则什么也不做</li>
<li>将cache做成函数，添加数据使用 cache(key,value)，而且函数本身也是对象<br>function cache(key,value){<br>//可以在这里加上限定长度的代码<br>cache[key]=value;<br>}<br>由于需要记录键的数量，并且需要记录添加数据的先后顺序，所以首先考虑有序的数组，因此需要让cache函数带有缓存功能（这个数组就是）</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（3）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、函数声明与变量声明在一起的时候的注意点"><a href="#一、函数声明与变量声明在一起的时候的注意点" class="headerlink" title="一、函数声明与变量声明在一起的时候的注意点"></a>一、函数声明与变量声明在一起的时候的注意点</h4><blockquote>
<ul>
<li>函数的声明实际上包含两部分<ul>
<li>第一部分 告诉解释器 这个名字已经可以使用 （函数名，标识符）</li>
<li>第二部分 告诉解释器，这个名字代表着一个函数（变量里存储着函数的引用）</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>function func(){}
console.log(&apos;func&apos; in window)//当前执行环境中已经存在了func标识符
console.log(type func)//function
func=123;
console.log(func)//123
console.log(typeof func)
//获得对象的类型
console.log(Object.prototype.toString.call(func))
</code></pre><a id="more"></a>
<blockquote>
<ul>
<li><p>当函数声明与变量声明冲突的时候，只看谁先有数据<br>函数的声明比变量的声明意义多一层，声明变量，是告诉解释器当前环境可以使用该名字，而声明函数，是告诉解释器，除了可以使用该名字，该名字还表示一个函数体</p>
<ul>
<li>先var num;后function num…<ul>
<li>首先告知解释器有名字 num了</li>
<li>后面是函数声明，由于已经有num名字可以使用了，所以就不再告诉解释器可以使用num，而是直接将num与函数结合在一起</li>
</ul>
</li>
<li>先function num 后var num<ul>
<li>一开始已经有num了，而且是函数，其实就是告诉解释器有个num可以用了，所以后面的num；属于重复声明，直接无效</li>
</ul>
</li>
</ul>
</li>
<li><p>一个在新版本的浏览器中的特性</p>
</li>
</ul>
</blockquote>
<pre><code> if(true){
      function foo(){
          console.log(true);}
}else{
     function foo(){
          console.log(false);}
}
foo();
</code></pre><p>在早期的浏览器中（2015年）所有的浏览器（除了火狐）都是将其解释为声明，打印的是false，现在的浏览器最后的运行结果是true，表示if起到了作用</p>
<pre><code> if(true){
      function foo1(){
          console.log(true);}
}else{
     function foo2(){
          console.log(false);}
}

foo2();//error:foo2 is not function 已定义，但是函数未被指向
//虽然这两个函数不是声明，但是也不能解释成函数表达式
//如果是函数表达式foo1与foo2只能在函数内部使用
//因此不推荐把函数声明写在代码块中（if语句，循环，{}里面）
//有可能出现这样的问题：声明成功了一半（会在当前作用域中添加这个名字，代表可以使用。但是不会给他添加一层函数的含义）
</code></pre><h4 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h4><blockquote>
<ul>
<li>词法作用域</li>
<li>作用域：就是变量可以使用到不能使用的范围</li>
<li>块级作用域：<ul>
<li>块：代码块，即{}</li>
<li>变量的使用从定义开始，到其所在的块级作用域结束</li>
<li>代表语言：C，C++，C#，Java</li>
</ul>
</li>
<li>js词法作用域<ul>
<li>词法：就是定义，书写代码的规则</li>
<li>所以，所谓的词法作用域，就是在书写代码的时候，根据书写代码的结构就可以确定数据的访问范围的作用域</li>
<li>js不受块的影响，即使在块中定义声明变量，在块的外面依旧可以使用</li>
<li>所谓的js的词法作用域，就是根据预解析规则定义变量的使用范围，全部代码中只有函数可以限定范围，其它均不能限定访问范围。在函数内部是一个独立的作用范围结构</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="三、JS词法作用域的细节"><a href="#三、JS词法作用域的细节" class="headerlink" title="三、JS词法作用域的细节"></a>三、JS词法作用域的细节</h4><blockquote>
<ul>
<li>在没有函数的情况下，所有的变量的访问规则依据预解析规则</li>
<li>只有函数可以限定作用域，其它的不行</li>
<li>在函数内部是一个独立的完整的作用域结构</li>
<li>在函数内部，允许再定义函数，同时两个层次的函数都是作用域的独立体</li>
<li>允许在函数内，访问函数外的变量，前提是函数内没有该变量的声明<ul>
<li>优先访问当前作用域的数据</li>
</ul>
</li>
<li>结论<ul>
<li>词法作用域就是描述变量的访问范围：<ul>
<li>在代码中只有函数可以限定作用范围，允许函数访问外部的变量，反之不允许</li>
<li>在函数内优先访问内部声明的变量，如果没有才会访问外部的</li>
<li>所有变量的访问规则，按照预解析规则来访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="四、函数的参数"><a href="#四、函数的参数" class="headerlink" title="四、函数的参数"></a>四、函数的参数</h4><pre><code>(function ( a ) {
    console.log( a );
    var a = 10;
    console.log( a );
})( 100 );
</code></pre><blockquote>
<ul>
<li>函数定义参数，实际上就是在函数最开始的时候，有一个变量的声明 function（a）{}其含义就是，在已进入函数体，在所有操作开始之前（预解析之前）就有了该变量的声明</li>
</ul>
</blockquote>
<pre><code>(function ( a ) {
    console.log( a );
    var a = 10;
    console.log( a );
    function a () {
        console.log( a );
    }
    // a();
})( 100 );
</code></pre><ul>
<li>注意：先调用函数，函数内部才会开始预解析，相当于函数最开始的时候就有一个var a=100;</li>
</ul>
<p>###五、作用域链规则</p>
<blockquote>
<ul>
<li>什么是作用域链<br>就是在当前作用域链中如果要寻找一个内容，会先在当前作用域中寻找，如果没有找到就会渠道上一层作用域中继续寻找。。。一直找到全局作用域都没有的话，那么就找不到，报错。由于这种一环套一环的访问规则，这样的作用域构成一个链式结构，所以直接称其为作用域链<br>作用域链是用来做变量查找的，因此变量可以存储什么东西，链中就应该有什么东西，换句话说就是，链里面存储的是各种对象，可以将其想想成对象的序列（数组）</li>
<li>绘制作用域链的规则<ul>
<li>将所有的script标签作为一个链结构，标记为0级别的链</li>
<li>将全局范围内，所有的声明变量名和声明函数名按照代码的顺序标注在0级链中</li>
<li>由于每一个函数都 可以构成一个新的作用域链，所以每一个0级链上的函数都延展出1级链</li>
<li>分别在每一个函数中进行上述操作将函数中的每一个名字都标注在1级链中</li>
<li>每一条1级链中如果有函数，可以再次的延展出2级链，以此类推</li>
</ul>
</li>
<li>分析代码的执行<br> 当作用域链绘制完成后，代码的分析也需要一步一步的完成<ul>
<li>根据代码的执行顺序（从上往下，从左至右）在图中标记每一步的变量数据的变化</li>
<li>如果需要访问某个变量，直接在当前n级链上查找变量，查找无序</li>
<li>如果找到变量，直接使用，如果没有找到变量，在上一级，n-1级中查找</li>
<li>一直找下去，知道0级链，如果0级链还没有就报错，XXX is not defined；</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="一、小总结"><a href="#一、小总结" class="headerlink" title="一、小总结"></a>一、小总结</h4><blockquote>
<ol>
<li>混入——可以将一个对象的成员 混入 到另一个对象当中</li>
<li>混合式继承<ul>
<li>给原型对象添加一个混入的方法</li>
<li>使用混入的方法为原型对象添加成员</li>
<li>此时通过构造函数创建的对象就会继承原型当中的成员</li>
</ul>
</li>
<li>Object.create:以一个对象作为原型创建一个新的对象。优点——可以快速的创建一个相类似的对象</li>
<li>原型链结构：<ul>
<li>实例对象–》构造函数.原型–》Object.prototype–》null</li>
<li>内置对象–》内置对象构造函数.原型–》Object.prototype–》null</li>
<li>Object对象–》Object.prototype–》null<a id="more"></a></li>
</ul>
</li>
<li>动态函数：Function<ul>
<li>函数是一个对象，它应该也是由构造函数创建的，也应该有原型对象。Function就是函数（实例对象）的构造函数</li>
</ul>
</li>
<li>arguments对象<ul>
<li>对象中包含了传入的所有参数，他的length属性可以显示参数的个数</li>
</ul>
</li>
<li>函数.length——函数定义的时候参数的个数<br>函数.name——函数名</li>
<li>callee和caller<ul>
<li>callee：代表被调用的函数的引用</li>
<li>caller：代表调用函数的函数（调用者）</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="二、eval函数"><a href="#二、eval函数" class="headerlink" title="二、eval函数"></a>二、eval函数</h4><blockquote>
<ol>
<li>eval函数与Function功能类似，eval可以直接将字符串作为代码来执行<ul>
<li>语法：eval（语句字符串）</li>
<li>注意：它好像与当前代码处于同一个作用域</li>
<li>可以直接调用eval函数，来实现字符串代码</li>
</ul>
</li>
<li>eval函数和Function的比较<ul>
<li>A 语法特点<ul>
<li>eval简洁，直接调用即执行</li>
<li>Function是用来生成函数中的，所以如果要执行，需要调用</li>
<li>立即执行函数（自调用函数）</li>
</ul>
</li>
<li>B 作用域<ul>
<li>eval就在执行函数的当前作用域  </li>
<li>在eval函数中，使用字符串声明的变量，在eval函数外面可以立即使用，即eval函数的执行作用域与当前环境作用域一致</li>
<li>Function是创建了一个新的函数，那么所有的东西，都只在函数内部起作用，除非：<ul>
<li>变量没有声明，直接使用</li>
<li>return</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>eval函数转json格式的字符串为对象<ul>
<li>json格式（更加严格的，国际通用数据表示协议）</li>
<li>在js中使用的json对象，相对较松散</li>
<li>json格式有两种结构<ul>
<li>{}对象的结构</li>
<li>[]数组的结构</li>
<li>注意：json格式中，键名也必须使用双引号括起来，在js中就没有这个要求了，较松散</li>
</ul>
</li>
<li>将字符串变成对象，有三种做法<ul>
<li>eval做法 </li>
<li>Function做法</li>
<li>使用ES5中引入的标准处理JSON的语法</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code>//eval做法
var o1=eval(data)   //注意一个习惯，就是数据两端加上圆括号为好
//Function做法
var o2 =(new Function(&apos;return&apos;+data))();
//ES5
</code></pre><p>处理JSON的做法<br>    JSON.parse() //注意：字符串必须是严格的json格式，双引号</p>
<blockquote>
<ol>
<li>为何转换json格式字符串需要圆括号<ul>
<li>eval函数本质是执行js代码的</li>
<li>eval是用来执行字符串表示的js代码的，所以隐含的数据里面{}实际上是代码块的含义<br>标签语法，即使将字符串写成json格式的形式也不行</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code>/*
label:
while () {
    while () {
        while () {
            ... 
            break label;
        }
    }
}
...
*/
</code></pre><h4 id="三、函数是Function的实例"><a href="#三、函数是Function的实例" class="headerlink" title="三、函数是Function的实例"></a>三、函数是Function的实例</h4><blockquote>
<ul>
<li>function（对象角度）是Function（构造函数）的实例</li>
<li>在该角度去看，函数就是对象，Function就是构造函数</li>
<li>函数对象（构造函数，系统函数，自定义函数）都是由Function创建出来的实例对象，即所有函数都是Function构造出来的实例</li>
<li>Function也是一个函数对象，它是由自己构造出来的，即Function是由Function构造出来的实例</li>
</ul>
</blockquote>
<h4 id="四、instanceof-运算符"><a href="#四、instanceof-运算符" class="headerlink" title="四、instanceof 运算符"></a>四、instanceof 运算符</h4><blockquote>
<ul>
<li>语法——返回的是boolean值 </li>
<li>对象 instanceof 构造函数</li>
<li>判断构造函数的原型属性，是否在对象的原型链上</li>
<li>A instanceof B——判断B的原型是否在A对象的原型链上</li>
</ul>
</blockquote>
<h4 id="五、不要过多依赖原型链"><a href="#五、不要过多依赖原型链" class="headerlink" title="五、不要过多依赖原型链"></a>五、不要过多依赖原型链</h4><blockquote>
<ul>
<li>js的继承：就是利用对象的动态特性添加成员，或直接替换对象的方式修改原型链结构，使得当前对象的原型链上的对象具有某些成员，那么我的当前对象就可以使用这些成员了<ul>
<li>过多的依赖原型链继承，会损耗性能</li>
<li>如果必须使用原型链继承，最好提供一些快速访问的方法</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="六、代码预解析"><a href="#六、代码预解析" class="headerlink" title="六、代码预解析"></a>六、代码预解析</h4><blockquote>
<ul>
<li>编译性语言：C，C++，C#，Java 就是需要一个‘翻译’程序，将源代码翻译成计算机可以读懂的二进制数据（指令）。然后存储成可执行文件。<br>提前翻译好，运行时直接执行的结果</li>
<li>解释型（脚本型）：javascript，SQL，……<br>代码在执行的时候，有一个翻译程序，读一句代码执行一句代码，再读一句代码，再执行一句代码</li>
<li>代码在执行之前，需要快速的‘预览’一遍，那么可以尽可能提高执行效率</li>
<li>在js中预解析的特点<ul>
<li>代码是如何执行的：读取js文件，预解析，一句一句执行</li>
<li>js在预解析的过程中完成了声明部分的标记与变量作用域的设定</li>
</ul>
</li>
<li>什么是js中的声明<ul>
<li>简单的说就是让js执行引擎知道有什么东西（标识符）</li>
<li>即代码在执行之前的预解析，首先让js的执行引擎在当前运行环境中，有什么东西（名字、标识符）是可以被使用的</li>
<li>console.log（num）</li>
</ul>
</li>
<li>在js中有哪些声明<br>标识符的声明（变量的声明）<br>函数的声明</li>
<li>变量的声明<ul>
<li>语法 ： var 变量名</li>
<li>目的：告诉解释器，有一个名字是一个变量，在当前环境中可以被使用</li>
</ul>
</li>
<li>语句：就是可以执行的东西，在代码执行的时候才会区运行<ul>
<li>var a = 123;凡是要去执行的东西都是一个语句，在使用var 声明变量，同时完成赋值的时候，实际上，预解析将其做了一定处理：</li>
<li>凡是读取到var的时候，就检查var紧跟的名字是否已经标记了</li>
<li>如果没有标记，就表明这个名字是一个标识符，需要被标记</li>
<li>如果已经被标记了，那么这个var被忽略</li>
</ul>
</li>
</ul>
</blockquote>
<p>结论：<br>  var a;<br>  var a=10;<br>等价于  var a; a=10;</p>
<h4 id="七、预解析的特点——变量名提升"><a href="#七、预解析的特点——变量名提升" class="headerlink" title="七、预解析的特点——变量名提升"></a>七、预解析的特点——变量名提升</h4><blockquote>
<ul>
<li>注意：‘字符串’ in 对象——该字符串描述的名字，是否在对象中存在一个属性，与之同名</li>
</ul>
</blockquote>
<pre><code>if( &apos;a&apos; in window ){
  var a=123;
}
console.log(a); //123;
</code></pre><h4 id="八、函数的声明"><a href="#八、函数的声明" class="headerlink" title="八、函数的声明"></a>八、函数的声明</h4><blockquote>
<ul>
<li>函数的各种定义形式<ul>
<li>声明式：function func(){}</li>
<li>表达式式（匿名函数，字面量函数，lambda函数）<br>var func=function(){};</li>
</ul>
</li>
<li>特点：<ul>
<li>函数的声明是独立于语句的，不需要加分号结束，也不能嵌入到代码表达式中</li>
<li>表达式式，本质上是使用函数表达式（字面量）给变量赋值，因此它是语句</li>
</ul>
</li>
<li>表达式：<ul>
<li>将运算符与操作数连接起来的式子</li>
<li>就是一个有结果的代码单元</li>
<li>字面量，有值，是表达式，是常量表达式</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="九、函数各种定义形式的异同"><a href="#九、函数各种定义形式的异同" class="headerlink" title="九、函数各种定义形式的异同"></a>九、函数各种定义形式的异同</h4><blockquote>
<ul>
<li>声明式（重点是语法）<ul>
<li>function func（）{}</li>
<li>函数声明是独立于代码执行的，代码在执行的时候，声明部分已在预解析阶段处理完毕，因此在代码调试阶段，无法给函数声明添加断点，而且由于预解析在执行之前完成，可以先调用，后声明函数，有时在开发的时候，将函数全部声明在后面，前面为了保证代码的紧凑，而直接调用。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="十、预解析的特点——各种函数定义形式的异同"><a href="#十、预解析的特点——各种函数定义形式的异同" class="headerlink" title="十、预解析的特点——各种函数定义形式的异同"></a>十、预解析的特点——各种函数定义形式的异同</h4><blockquote>
<ul>
<li>函数表达式<ul>
<li>使用这个方式定义函数，实际上是利用函数是js中的 一个数据类型的特点</li>
<li>利用赋值，使用变量存储函数的引用，此时没有函数的声明，但是有变量的声明</li>
<li>读取代码，发现 var func，存储func这个名字</li>
<li>开始执行代码，第一句是赋值语句，将函数赋值给func<br>执行</li>
<li>如果将调用放到赋值之前，就会报错</li>
</ul>
</li>
<li>函数表达式的名字问题<ul>
<li>函数.name可以用来获取函数的名字，表达式没有名字<br>我们的函数表达式也是可以带有函数名</li>
<li>var 函数名1=function 函数名2（）{}</li>
<li>当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式</li>
<li>引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数</li>
<li>函数表达式带有名，该名字只允许在函数内部使用，属于局部作用域</li>
<li>带有名字的函数表达式，函数的name属性即为该名字</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/04/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<ol>
<li><p>解决方案：</p>
<ul>
<li>使用js原生自带的一个对象，原型对象。</li>
<li>每一个函数，在创建的时候，就自带 了一个prototype属性，通过prototype就可以访问原型对象</li>
<li>在对象创建的时候，对象会默认创建一个原型对象，当执行对象方法的时候，对象没有这个东西，就会去在原型上找<a id="more"></a>
</li>
</ul>
</li>
<li><p>什么东西应该被加载原型上面，什么东西应该被放在对象中</p>
<ul>
<li>假设这个方法是公用的（所有的对象都拥有的功能），数据是共享的，那么它就应该被放到原型中，独有的数据，独有的行为应该被放在对象中</li>
</ul>
</li>
<li><p>针对构造函数而言，原型就是构造函数的prototype属性，常常将其称为原型属性，针对实例对象而言，原型就是实例对象的原型对象。</p>
</li>
<li><p>一般如何使用原型对象</p>
<ul>
<li>简单的说就是将共享的方法放到原型中，而独有的数据与行为放在当前对象里<br>①直接通过动态特性给原型对象添加成员，例如：Person.prototype.eat<br>②直接替换原型对象，让 Person.prototype 指向另一个对象. 直接赋值 如：Person.prototype={constructor:Person,};（注意：手动的添加constructor属性，表示对应的构造函数）</li>
</ul>
</li>
</ol>
<p>A方法是给系统提供的原型对象添加功能<br>B方式是换了一个对象，不适用系统的对象了</p>
<ol>
<li><p><strong>proto</strong></p>
<ul>
<li>早期浏览器是不支持<em>proto</em>，火狐率先使用该属性，但是是非标准的</li>
<li>基本现在的新浏览器都支持该属性（ie8不支持该属性）</li>
<li>在实际开发中不建议使用，但可以用于调试<br>访问</li>
<li>使用构造函数，就使用prototype属性访问原型</li>
<li>使用实例对象，就使用非标准的<em>proto</em>属性访问原型<br>其实他们访问的是一个东西</li>
</ul>
</li>
<li><p>兼容低版本</p>
<ul>
<li>使低版本浏览器支持<br>第一步：判断系统是否支持<em>proto</em><br>if({}.<em>proto</em>){cl(‘支持’);}else{cl(‘不支持’);}<br>为了模拟该用法，不适用<em>proto</em> 去访问原型<br>要访问原型最保险的办法就是利用构造函数，只要实例对象，可以访问到constructor就可以了</li>
</ul>
</li>
</ol>
<p>如果实例对象没有这个东西，会去原型上找<br>p1.constructor.prototype</p>
<ol>
<li><p>继承的概念与原型式继承</p>
<ul>
<li>什么是继承<br>自己没有，但是别人有，拿过来自己用，就好像是自己的一样</li>
<li>原型与实例对象<br>在js中，方法定义在原型对象中，而属性定义在实例对象中，调用方法的时候，实例对象本身是没有该成员的，但是依旧可以调用该方法，好像这个方法就是该实例对象的一样，因此，我们称该实例对象继承自原型对象</li>
<li>任何一个实例，都是继承自其原型对象的，即原型式继承</li>
</ul>
</li>
<li><p>为什么需要继承</p>
<ul>
<li>编程的发展<br>复用（重复使用）</li>
<li>js运行效率<br>共享特性<br>复用<br>组件化  菜单的一套控件</li>
</ul>
</li>
<li><p>传统面向对象语法特征</p>
</li>
<li><p>相关概念与说明<br>构造函数：本质上是一个函数，但是我们可以通过new来调用这个函数并且创建一个实例对象<br>实例对象：本质上是一个对象{}，但是我们是通过构造函数来创建的实例对象，通过构造函数的参数我们可以给实例对象添加一些成员<br>实例成员：就是实例对象的属性或者方法<br>静态成员：指的是构造函数的属性或者方法，什么东西会设置成静态的成员呢？比如说工具方法</p>
</li>
<li><p>属性搜索原则（成员搜索原则）</p>
<ul>
<li>对象在调用方法或者访问属性的时候，首先在当前对象中查询，如果有该成员使用并停止查找</li>
<li>如果没有该成员，就在其原型对象中查找，如过有该成员即使用并停止查找</li>
<li>如果还没有找到，就到该对象的原型对象的原型对象中查找<br>…………</li>
<li>最后会查到Object.prototype上，如果还没有即返回undefined;</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP基础语法]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/03/17/PHP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>文件以.php后缀结尾，所有程序包含在&lt;?php /<strong> 这里是代码 </strong>/ ?&gt;</p>
<img src="/mangomao/uploads/php/1.png">
<p>避免使用中文目录和中文文件名</p>
<a id="more"></a>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>变量以$开头 字母/数字/下划线 不能以数字开头</li>
<li>大小写敏感（区分大小写）</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>字符型、整型、浮点型、布尔型、数组、对象、NULL</li>
<li>单引号&amp;双引号区别</li>
<li>索引数组、关联数组（了解即可）</li>
</ul>
<h1 id="内容输出"><a href="#内容输出" class="headerlink" title="内容输出"></a>内容输出</h1><ul>
<li>echo：输出简单数据类型，如字符串、数值</li>
<li>print_r()：输出复杂数据类型，如数组</li>
<li>var_dump()：输出详细信息，如对象、数组</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>基本与Javascript语法一致<br>. 号表示字符串拼接符，Javascript中为+号</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>与Javascript基本一致<br>函数名对大小写不敏感<br>默认参数（了解即可）</p>
<h1 id="分支、循环语句"><a href="#分支、循环语句" class="headerlink" title="分支、循环语句"></a>分支、循环语句</h1><p>与Javascript基本一致<br>foreach()</p>
<h1 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h1><p>include、require</p>
<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><p>表单name属性的是用来提供给服务端接收所传递数据而设置的<br>表单action属性设置接收数据的处理程序<br>表单method属性设置发送数据的方式<br>当上传文件时需要设置 enctype=”multipart/form-data”，且只能post方式<br>$_GET接收 get 传值<br>$_POST接收 post 传值<br>$_FILES接收文件上传</p>
<h2 id="1、get方式"><a href="#1、get方式" class="headerlink" title="1、get方式"></a>1、get方式</h2><img src="/mangomao/uploads/php/2.png">
<img src="/mangomao/uploads/php/3.png">
<h2 id="2、post-方式"><a href="#2、post-方式" class="headerlink" title="2、post 方式"></a>2、post 方式</h2><img src="/mangomao/uploads/php/4.png">
<img src="/mangomao/uploads/php/5.png">
<h2 id="3、文件上传"><a href="#3、文件上传" class="headerlink" title="3、文件上传"></a>3、文件上传</h2><img src="/mangomao/uploads/php/6.png">
<img src="/mangomao/uploads/php/7.png">
<h1 id="常用PHP函数"><a href="#常用PHP函数" class="headerlink" title="常用PHP函数"></a>常用PHP函数</h1><p>in_array() 是否在数组中<br>count() 计算数组长度<br>array_key_exists ()检测数组中是否存在key<br>file_get_contents读取文件<br>…还有很多</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>https://mango-mao.github.io/mangomao/2016/02/12/jQuery/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天看到这样一句jquery源码<br><code>(function (window, undefined){})(window)</code></p>
</blockquote>
<ul>
<li>第一眼：这是啥？</li>
<li>第二眼：这是干啥？</li>
<li>第三眼：为啥？</li>
<li><p>然后……</p>
<a id="more"></a>
</li>
<li><p>终于在各种资料查询</p>
</li>
<li><p>勇敢抱大腿后</p>
</li>
<li><p>拨开云雾见青天</p>
</li>
<li><p>必须得了个瑟~</p>
</li>
<li><p>ECMAScript执行JS代码是从里到外</p>
</li>
<li>因此把全局变量<em>window</em>对象传进来</li>
<li>就避免了到外层去寻找</li>
<li>减少作用域链的查询时间，提高效率</li>
<li>当然</li>
<li><p>如果你的插件用不到<em>window</em>对象，那么就不用传递这个参数啦</p>
</li>
<li><p>而且<br><code>(function(window, undefined))里的window和undefined</code></p>
</li>
<li>均可以替换成其他简写字符（比如L）</li>
<li>那么在压缩的时候可以减少字节数</li>
<li><p>即可以减少文件大小</p>
</li>
<li><p>再说回<em>undefined</em></p>
</li>
<li>在旧的浏览器中<em>undefined</em>可以被重新赋值</li>
<li>在被重新赋值后,使用<em>undefined</em>指令将不能正确的检测一个变量是否被赋值</li>
<li>总之，会影响到内部的<em>undefined</em></li>
<li>jQuery框架考虑到这个问题</li>
<li><p>因此增加一个形参<em>undefined</em></p>
</li>
<li><p>使用时最好就是不传实际参数</p>
</li>
<li>此时形参的<em>undefined</em>就是真正的<em>undefined</em>了</li>
<li>记住，这里不是在说绕口令哦~</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/08/17/HTTP%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>指服务器和客户端间进行通信时的约束和规范，客户端与服务端的数据交互并不是杂乱无章的，需要遵照（基于）一定的规范进行。</p>
<h1 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h1><ul>
<li>HTTP、HTTPS 超文本传输协议 </li>
<li>FTP 文件传输协议</li>
<li>SMTP 简单邮件传输协议</li>
</ul>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>即超文本传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。<br>HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。<br>即HTTP协议主要由请求和响应构成。</p>
<img src="/mangomao/uploads/http/1.png">
<a id="more"></a>
<p>常用请求方法 POST、GET、PUT、DELETE</p>
<h1 id="请求-请求报文"><a href="#请求-请求报文" class="headerlink" title="请求/请求报文"></a>请求/请求报文</h1><p>请求由客户端发起，其规范格式为：请求行、请求头、请求主体。</p>
<img src="/mangomao/uploads/http/2.png">
<h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><img src="/mangomao/uploads/http/3.png">
<p>由请求方式、请求URL和协议版本构成</p>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>Host：localhost请求的主机<br>Cache-Control：max-age=0控制缓存<br>Accept：<em>/</em> 接受的文档MIME类型<br>User-Agent：很重要<br>Referer：从哪个URL跳转过来的<br>Accept-Encoding：可接受的压缩格式</p>
<h2 id="请求主体"><a href="#请求主体" class="headerlink" title="请求主体"></a>请求主体</h2><p>即传递给服务端的数据<br>注：当以post形式提交表单的时候，请求头里会设置<br>Content-Type: application/x-www-form-urlencoded，以get形式当不需要</p>
<h1 id="响应-响应报文"><a href="#响应-响应报文" class="headerlink" title="响应/响应报文"></a>响应/响应报文</h1><p>响应由服务器发出，其规范格式为：状态行、响应头、响应主体。</p>
<img src="/mangomao/uploads/http/4.png">
<p>1、状态行</p>
<img src="/mangomao/uploads/http/5.png">
<p>由协议版本号、状态码和状态信息构成</p>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>Date：响应时间<br>Server：服务器信息<br>Content-Length：响应主体长度<br>Content-Type：响应资源的MIME类型<br>MIME是标识文件类型的，文件后缀并不能正确无误的标识文件的类型。<br>客户端与服务器在进行数据传输的时候都是以字节形式进行的，咱们可以理解成是以“文本形式”传输，这时浏览器就需要明确知道该怎么样来解析这些文本形式的数据，MIME就是明确告知浏览器该如何来处理。</p>
<h2 id="响应主体"><a href="#响应主体" class="headerlink" title="响应主体"></a>响应主体</h2><p>即服务端返回给客户端的内容；<br>状态码</p>
<p>常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误</p>
<img src="/mangomao/uploads/http/6.png">
<h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><p>利用HTTP抓包工具在开发中可以帮我们进行调试，常用抓包工具HttpWatch、Fiddler、Charles、FireBug等<br>浏览器插件<br>Firebug、HttpWatch、chrome dev tools<br>代理软件<br>Charles、Fiddler</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写移动项目时遇到的问题(一)]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/05/17/%E5%86%99%E7%A7%BB%E5%8A%A8%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="点击高亮效果"><a href="#点击高亮效果" class="headerlink" title="点击高亮效果"></a>点击高亮效果</h1><pre><code>-webkit-tap-highlight-color : transparent;/*清除点击高亮效果*/
</code></pre><p>在移动端浏览器会遇见点击出现高亮的效果，在某项项目是不需要这个默认的效果的。那么我们通常会把这个点击的颜色设置成透明。</p>
<h1 id="所有盒子以边框开始计算"><a href="#所有盒子以边框开始计算" class="headerlink" title="所有盒子以边框开始计算"></a>所有盒子以边框开始计算</h1><pre><code>/*设置宽度以边框开始计算*/
-webkit-box-sizing: border-box;
box-sizing: border-box;
</code></pre><p>在移动端通常使用的是百分比布局，那么这样的布局如果使用border或者padding或使容器的宽度超出屏幕的宽度产生滚动条。那么我们的解决方案是什么试用css3属性 box-sizing设置所有的盒子重边框开始计算宽度。</p>
<h1 id="Input清除默认的样式"><a href="#Input清除默认的样式" class="headerlink" title="Input清除默认的样式"></a>Input清除默认的样式</h1><pre><code>/*在移动端怎么清除默认的样式*/
/*在移动端清除浏览器默认样式*/
-webkit-appearance: none;
</code></pre><blockquote>
<p>在移动设备的浏览器当中表单一般会有默认的属性  通过border：none<br>outline：none是无法完全清楚的，还是会有一些浏览器默认的属性，比如：<br>内阴影，立体感、、、向这些浏览器默认加上的样式我们怎么去除呢？<br>我们有一个属性  -webkit-appearance 这个属性指的是设置成 none</p>
</blockquote>
<h1 id="最小宽度和最大宽度的限制"><a href="#最小宽度和最大宽度的限制" class="headerlink" title="最小宽度和最大宽度的限制"></a>最小宽度和最大宽度的限制</h1><pre><code>max-width: 640px;  /* 在行业当中的移动端的设计图一般使用的是640px*/
min-width: 320px;  /*在移动设备当中现在最小的尺寸320px*/
</code></pre><p>适用:<br>图片比较多的首页，门户，电商 等。<br>作用:</p>
<ul>
<li>保证页面在尺寸比较大的设备当中保证页面的效果也就是清新度</li>
<li>保证页面在小尺寸的设备当中有较好的布局效果。</li>
</ul>
<h1 id="Img的下间隙问题"><a href="#Img的下间隙问题" class="headerlink" title="Img的下间隙问题"></a>Img的下间隙问题</h1><pre><code>&lt;div&gt;
abcdefghijklmnopqrstuvwxyz 
&lt;img src=&quot;../images/nv-fy.jpg&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
</code></pre><p>文字基线默认的 baseline 是以X的下边开始的<br>Img是行内块级元素  它也会有默认的基线对齐。那么和文字一样也会距离底部有一定的间隙。<br>解决:<br>    vertical-align:middle;</p>
<h1 id="图片模糊的原因以及解决方法"><a href="#图片模糊的原因以及解决方法" class="headerlink" title="图片模糊的原因以及解决方法"></a>图片模糊的原因以及解决方法</h1><p>1：1的显示在移动设备当中图标会失真原因是什么如何解决？<br>在高清屏当中会用两个或多个物理像素来显示实际的1px图片内容</p>
<img src="/mangomao/uploads/mobile/1.png">
<p>那么其实就是相当于把1px的图片放大显示了，所以有毛边的图片一般都会失真，也就是显示模糊。</p>
<p>解决方案:<br>采用压缩图标尺寸的方式来解决。<br>如果是Img使用直接设置宽高的方式来压缩。<br>如果是背景使用的是设置background-size的方式来压缩</p>
<h1 id="搜索按钮调用"><a href="#搜索按钮调用" class="headerlink" title="搜索按钮调用"></a>搜索按钮调用</h1><pre><code>&lt;!--在移动端点击弹出输入法  enter键会显示搜索--&gt;
&lt;form action=&quot;#&quot;&gt;
    &lt;input type=&quot;search&quot; placeholder=&quot;提示&quot;/&gt;
&lt;/form&gt;
</code></pre><p>search定义用于输入搜索字符串的文本字段。<br>在移动端调用输入法的时候会弹出小键盘，键盘一般是enter键，那么在搜索框当中我们要求调用是搜索按钮，那么这样的结构才能调用出来。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/02/12/HTML5%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="基础API提升"><a href="#基础API提升" class="headerlink" title="基础API提升"></a>基础API提升</h4><ul>
<li>document.getElement……appendChild……都属于基础API</li>
<li>alt +右键往下滑</li>
<li><p>新选择器</p>
<ul>
<li><code>document.querySelector(selector)</code>——返回第一个满足选择器条件的元素，返回一个dom对象<ul>
<li>代码段 qs=querySelector</li>
<li>ae=addEventListenter</li>
</ul>
</li>
<li><code>docuemnt.querySelectorAll(&quot;.item&quot;)</code>——返回所有满足该条件的元素，返回元素类型为dom对象的数组</li>
<li>$（”.item”）——返回一个jQuery对象（dom元素的数组）</li>
<li>本质上jQuery的方式和querySelector的方式都是获取DOM数组，只不过jQuery会多一些其它成员</li>
<li>DOM数组的每一个成员注册事件不能像jQuery一样直接注册，必须分别给每个元素添加</li>
<li>h5就是将我们经常需要的操作又包装一层，原生API</li>
</ul>
<a id="more"></a>
</li>
<li><p>Element.classList</p>
<ul>
<li>新H5中DOM对象多了一个classList属性，是一个数组</li>
<li>a标签有个默认跳转</li>
<li>this.classList.add()——添加一个新的类名</li>
<li>this.classList.remove()——删除一个类名</li>
<li>this.classList.contains()——判断是否包含一个指定的类名</li>
<li><p>this.classList.toggle()——切换一个class</p>
<ul>
<li>toggle函数的第二个参数true为添加，false删除</li>
</ul>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断当前classList中有没有active</span></div><div class="line"><span class="keyword">var</span> link=<span class="built_in">document</span>.querySelector(<span class="string">".bar"</span>);</div><div class="line">link.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="comment">//toggle函数的第二个参数是true为添加，false为删除</span></div><div class="line">  <span class="keyword">var</span> exist =<span class="keyword">this</span>.classList.contains(<span class="string">"active"</span>);</div><div class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">"active"</span>,!exist);</div><div class="line">  e.preventDefault();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问历史API</p>
<ul>
<li><p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态</p>
</li>
<li><p>go函数可以传入一个地址，不传默认刷新</p>
</li>
<li><p>window.history.forward()</p>
</li>
<li><p>auto file name(插件plugin名字)</p>
</li>
<li><p>不建议用*号把默认样式去掉，效率低</p>
</li>
<li><p>默认样式有必要，只不过为了统一设置</p>
</li>
<li><p>当我们在伪造的访问历史中前进或后退时会执行一个popstate事件。</p>
</li>
<li><p>通过JS可以加入一个访问状态</p>
</li>
<li><p>history.pushState(放入历史中的状态数据，设置title（现在浏览器不支持）)</p>
</li>
<li><p>window.location可以拿到当前网页中跟地址相关的信息（location是个对象）  hash是锚点值</p>
</li>
<li><p>decodeURI作用就是从URL编码转换到之前的状态</p>
</li>
<li><p>encode反作用</p>
</li>
<li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"add()"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加一个历史记录"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//判断浏览器是否支持这个API</span></div><div class="line">      <span class="keyword">if</span>(<span class="built_in">window</span>.history &amp;&amp; history.pushState)&#123;</div><div class="line">        history.pushState(<span class="string">"数据"</span>,<span class="string">"设置历史状态显示的标题，但是浏览器不支持"</span>，<span class="string">"？demo="</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().toLocalTimeString());</div><div class="line">      &#125;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>new Date()  获取的是一个时间对象</p>
</li>
<li><p>toLocalTimeString 转换成我们能认识的时间字符串</p>
</li>
<li><p>toDateTimeString 转换成我们能认识的日期字符串</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> title=<span class="built_in">window</span>.location.search.split(<span class="string">"="</span>)[<span class="number">1</span>];</div><div class="line"><span class="keyword">if</span>(title)&#123;</div><div class="line">  <span class="comment">//有值</span></div><div class="line"> <span class="comment">//如果地址栏中的地址有中文，会以URL编码方式呈现</span></div><div class="line">  content.innerHTML=data[<span class="built_in">decodeURI</span>(data)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>class</p>
<ul>
<li><p>之前</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h1=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> list =h1.className.split(<span class="string">" "</span>);</div><div class="line">list.push(<span class="string">"class4"</span>);</div><div class="line">h1.className=list.join(<span class="string">" "</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>通过dom对象的classList，className是字符串的形式，classList是数组的形式</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> h1=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> list=h1.classList</div></pre></td></tr></table></figure>
</li>
<li><p>通过classList封装了一些针对增加、删除、切换的方法——add(“newclass”)； remove(“oldclass”)； toggle(“cl”)  存在则删除，不存在添加；contains()是否包含</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>控制台clear（）</p>
<h4 id="全屏API"><a href="#全屏API" class="headerlink" title="全屏API"></a>全屏API</h4><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = 需要全屏的元素；</div><div class="line"><span class="keyword">if</span>(&#123;elem.webkitRequestFullScreen)&#123;</div><div class="line">  elem.webkitRequestFullScreen();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.mozRequestFullScreen)&#123;</div><div class="line">  elem.webkitRequestFullScreen();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.requestFullScreen)&#123;</div><div class="line">  elem.requestFullScreen();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>需要操作用户的界面的时候，都需要得到用户的允许</p>
</li>
<li><p>if()return  不写{}，只能在单句代码的时候才可以这样操作</p>
</li>
<li><p>在全屏后，背景颜色会不起作用，得单独设置</p>
</li>
<li><p>给元素全屏或者document.body全屏</p>
</li>
</ul>
<h4 id="网页存储"><a href="#网页存储" class="headerlink" title="网页存储"></a>网页存储</h4><ul>
<li><p>application cache——可以让网页离线访问</p>
</li>
<li><p>google开发工具有个功能可以断开网络——network》》no throttling 》可以模拟网络</p>
</li>
<li><p>tab键不起作用时，可以用Ctrl+E</p>
</li>
<li><p>：：before是元素一开始的时候，在元素内部</p>
</li>
<li><p><code>&lt;html lang=&quot;en&quot; manifest=&quot;cache.mainfest&quot;&gt;</code>——manifest属性对应指向一个文件，这个文件称之为H5的缓存清单。这个路径是相对路径</p>
<ul>
<li><p>应用程序缓存 正常开发</p>
</li>
<li><p>给html添加一个manifest属性指向一个文件</p>
</li>
<li><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CACHA MANIFEST</div><div class="line"><span class="meta"># version 1.0.0</span></div><div class="line"><span class="symbol"></span></div><div class="line">CACHA:<span class="comment">//代表缓存下可以访问的文件，哪些文件可以缓存下来</span></div><div class="line">	index.html<span class="comment">//这里需要缩进</span></div><div class="line">	script.js</div><div class="line">	style.css</div><div class="line"><span class="symbol"></span></div><div class="line">NETWORK:<span class="comment">//哪些文件在有网络的情况下可以访问</span></div><div class="line">	*</div></pre></td></tr></table></figure>
</li>
<li><p>markdown编辑器，可以离线访问，得之前访问过，有过缓存才可以</p>
</li>
</ul>
</li>
</ul>
<h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul>
<li><p>localStorage(生命周期是永久的) &amp; sessionStorage（浏览器结束的时候就没有了，用法是一样的）</p>
</li>
<li><p>getItem方式获取一个不存在的键，返回空字符串，而[]返回undefined</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btnSet = <span class="built_in">document</span>.querySelector(<span class="string">"#btn_set"</span>);</div><div class="line"><span class="keyword">var</span> btnGet = <span class="built_in">document</span>.querySelector(<span class="string">"#btn_get"</span>);</div><div class="line"><span class="keyword">var</span> txtValue = <span class="built_in">document</span>.querySelector(<span class="string">"#txt_value"</span>);</div><div class="line">btnGet.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//txtValue.value=localStorage.getItem("key1");</span></div><div class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)</div><div class="line">  txtValue.value=localStorage(<span class="string">"key1"</span>);</div><div class="line">&#125;);</div><div class="line">btnSet.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//localStorage.setItem("key1",txtValue.value);</span></div><div class="line">  localStorage[<span class="string">"key1"</span>]=txtValue.value;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>id以下划线，class以中划线</p>
</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>提供客户端本地操作文件的可能</li>
<li>file API</li>
<li>文件域 <input type="file" id="" multiple></li>
<li>对于表单里的input来说：可以直接通过表单的name属性找到它</li>
<li>document.form[0].input_file</li>
<li>multiple是让文件域可以多选</li>
<li>可以通过在控制台输入document.form[0].input_file.files 可以查看已经上传的文件，以数组的形式呈现</li>
<li>lastModified——表示最近修改时间</li>
<li>lastModifiedDate——date对象</li>
<li>​:happy: v3.bootcss.com</li>
<li>js里面常用单引号</li>
</ul>
<h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h4><ul>
<li>支持网页内的拖放</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2015/01/12/HTML5%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="浏览器与服务器之间的交互过程"><a href="#浏览器与服务器之间的交互过程" class="headerlink" title="浏览器与服务器之间的交互过程"></a>浏览器与服务器之间的交互过程</h5><ol>
<li><p>用户在浏览器的地址栏中输入网站的地址</p>
</li>
<li><p>浏览器将请求报文发送给地址栏中网站的服务器</p>
</li>
<li><p>服务器根据请求报文返回页面数据给浏览器</p>
</li>
<li><p>浏览器得到响应的数据以后将之呈现给用户</p>
</li>
</ol>
<h5 id="请求报文和响应报文——审查元素-》network"><a href="#请求报文和响应报文——审查元素-》network" class="headerlink" title="请求报文和响应报文——审查元素 》network"></a>请求报文和响应报文——审查元素 》network</h5><ol>
<li><p>请求报文：浏览器发送给服务器的</p>
</li>
<li><p>响应报文：服务器返回给浏览器的</p>
</li>
</ol>
<a id="more"></a>
<h5 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h5><ul>
<li>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。</li>
<li>浏览器内核（Rendering Engine）：负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>IE：trident；  Safari：webkit；Firefox：gecko；chrome、Opera：blink</li>
</ul>
<h5 id="文件的后缀名"><a href="#文件的后缀名" class="headerlink" title="文件的后缀名"></a>文件的后缀名</h5><ul>
<li>修改文件的后缀名是不会改变内容，只决定打开方式</li>
<li>H系列标签作用：把页面上的文字加上标题的语义</li>
</ul>
<h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul>
<li>http协议<ul>
<li>请求报文</li>
<li>响应报文</li>
<li>URL：协议名、服务器的IP地址、端口号、请求文件的名称</li>
</ul>
</li>
<li>浏览器接受用户操作——浏览器封装HTTP请求——链接服务器：DNS解析——发送请求Request——服务器接收请求——处理请求——返回响应报文——浏览器接收响应报文——渲染页面呈现</li>
<li>如果没有设置端口号那么默认的端口是：80</li>
</ul>
<p>图片是另外请求</p>
<p>继续渲染与请求服务器的图片</p>
<h5 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h5><ul>
<li>img：图片标签</li>
<li>src：标签的属性，设置图片的路径</li>
<li>Alt：如果图片不存在，设置图片的文本信息</li>
<li>title：设置图片的提示信息，当鼠标悬停在图片上方的时候，就会显示提示信息</li>
</ul>
<h5 id="访问有图片的网页时，浏览器和服务器的交互过程"><a href="#访问有图片的网页时，浏览器和服务器的交互过程" class="headerlink" title="访问有图片的网页时，浏览器和服务器的交互过程"></a>访问有图片的网页时，浏览器和服务器的交互过程</h5><ul>
<li>用户在地址栏中输入一个网页的网址，按回车</li>
<li>浏览器就会向这个地址的服务器发送一个请求报文</li>
<li>服务器根据请求报文返回网页的页面数据给浏览器</li>
<li>浏览器解析返回的响应报文，并渲染显示</li>
<li>当浏览器解析到图片的时候，它不知道图片是在哪里的，所以，浏览器会再发送一次请求报文，去请求服务器的那一张图片</li>
<li>然后等待服务器返回图片的响应的时候，浏览器还会继续解析下面的其它内容</li>
</ul>
<h5 id="路径分为两种情况"><a href="#路径分为两种情况" class="headerlink" title="路径分为两种情况"></a>路径分为两种情况</h5><ul>
<li>绝对路径：从盘符开始寻找路径</li>
<li>相对路径：从当前页面开始寻找路径</li>
</ul>
<h5 id="a标签使用的地方"><a href="#a标签使用的地方" class="headerlink" title="a标签使用的地方"></a>a标签使用的地方</h5><ul>
<li>空连接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></li>
<li>去到其它的网页：<code>&lt;a href=&quot;其它的网页.html&quot;&gt;</code></li>
<li>去到其它页面的某一个地方，在跳转的页面进行定位 <code>&lt;a href=&quot;其它的网页.html#id&quot;&gt;</code></li>
<li>去到本页面的某一个地方：<code>&lt;a href=&quot;#id&quot;&gt;</code></li>
<li>下载（不建议）</li>
</ul>
<h5 id="a标签的属性target"><a href="#a标签的属性target" class="headerlink" title="a标签的属性target"></a>a标签的属性target</h5><ul>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_blank&quot;&gt;将会用新的页面打开1.html&lt;/a&gt;</code></li>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_self&quot;&gt;将会在当前的页面打开1.html&lt;/a&gt;</code></li>
<li>base 为页面上所有a标签设置跳转的方式（base标签一般放在title下面，写在head里面）<code>&lt;base target=&quot;_blank&quot;&gt;</code></li>
</ul>
<h5 id="DOCTYPE文档类型"><a href="#DOCTYPE文档类型" class="headerlink" title="DOCTYPE文档类型"></a>DOCTYPE文档类型</h5><ul>
<li>DTD 文档类型定义</li>
<li>html和XHTML规范<ul>
<li>html：3种<ul>
<li>strict</li>
<li>transitional（用的最多）</li>
<li>frameset</li>
</ul>
</li>
<li>XHTML：3种</li>
</ul>
</li>
<li>lang 用来设置当前页面的语言<ul>
<li>设置页面上主要使用语言的类型</li>
<li>将来做SEO的时候在权重上起到一定的作用</li>
<li>用于特殊设备上的设置，eg，盲人设备</li>
</ul>
</li>
</ul>
<h5 id="关于SEO"><a href="#关于SEO" class="headerlink" title="关于SEO"></a>关于SEO</h5><ul>
<li>搜索引擎优化（网站在搜索页面上的排名靠前）<ul>
<li>买排名，不靠谱</li>
<li>将页面做成静态页面（html）</li>
<li>发外链</li>
<li>页面的友好性（规范）：在合适的地方使用合适的标签，合理的使用标签的语义化</li>
</ul>
</li>
<li>讨好搜索引擎<ul>
<li>网络爬虫，搜索引擎机器人：收录Internet上的网站，找到访问量高的，语义化好的网站，最后将这些网站作为搜索的结果呈现给用户观看  任务：就是用来访问页面给页面排序，从而在用户搜索的时候可以有一个先后的排名</li>
</ul>
</li>
<li><p>让网站更靠前的方式：</p>
<ul>
<li>买排名，不靠谱</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h5><ul>
<li>作用：让页面拥有一个属于自己的标题</li>
<li>title中的文本在SEO中占有很大的权重</li>
<li>h1,h2</li>
</ul>
<h5 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h5><ul>
<li>注意：meta中设置的所有的内容在页面都不会显示，</li>
</ul>
<ul>
<li><p>description 可以描述页面，可以用来使用百度程序（网络爬虫）来收录关键信息，以此提高页面的排名</p>
</li>
<li><p>keywords  关键词，可以用来提高页面的关键词的比重的一种方式，:angry:英文的逗号</p>
</li>
<li><p>最多不要超过十个</p>
</li>
<li><p>charset</p>
<ul>
<li><p>字符集：相当于一个字库，在这个字库有很多的文字，每一个文字都有对应的编码</p>
</li>
<li><p>当你设置的网页的编码格式和保存的编码格式不一样的时候，就会发生乱码</p>
</li>
<li><p>gb2312：国际标准，收录了汉字，片假名</p>
</li>
<li><p>gbk：国标扩（扩展版），一个文字2个字节</p>
</li>
<li><p>UTF-8：收录全世界所有的语言中的文字，一个文字3个字节</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul>
<li>无序列表<ul>
<li>ul标签的作用：表示在这里有一个无序的列表</li>
<li>li标签的作用：表示列表的项</li>
<li>注意：ul不能单独出现，ul里面一定要放li，li是一个容器，放什么其他的标签都可以</li>
</ul>
</li>
<li>有序列表<ul>
<li>作用：显示一段有顺序的数据</li>
<li>语义：一组有顺序的数据</li>
</ul>
</li>
<li>自定义列表：dl,dt,dd<ul>
<li>dl标签：写一个自定义列表</li>
<li>dt标签：它代表的就是这儿有一个自定义的列表项</li>
<li>dd标签：代表dt对应的列表项中的具体内容</li>
</ul>
</li>
</ul>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><ul>
<li><p>table标签：表示是一个表格的内容</p>
</li>
<li><p>tr标签：表示是表格中的一行</p>
</li>
<li><p>td标签：表示是表格中的一个单元格</p>
</li>
<li><p>表格的其它标签和属性：</p>
<ul>
<li>表格的属性：<table border="1" cellspacing="" cellpadding=""> <ul>
<li>border：设置表格的边框的宽度 </li>
<li>cellspacing：设置的是表格中的单元格之间的距离</li>
<li>cellpadding：设置的是单元格中的内容与单元格之间的距离</li>
<li>width</li>
<li>height</li>
</ul>
</table></li>
</ul>
</li>
<li><p>表格中的其他标签</p>
<ul>
<li>th标签：设置表头，具体表现的效果是文字加粗，居中</li>
<li>caption标签：设置标题的标题，注意，caption标签应该放在table标签后面</li>
<li>thead标签：设置的是表格的头部信息，一般th的内容都应该放在这里</li>
<li>tbody标签：设置的是表格的主题内容，一般td的内容都放在这里</li>
<li>tfoot标签：设置的是表格的尾部信息，一般是放一些总结性的信息</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h5><ul>
<li><code>&lt;input type=&quot;hidden&quot; value=&quot;&quot;&gt;</code> 学习ajax时候用到</li>
<li><input type="text" value="默认值">：输入框</li>
<li><input type="password">：密码框</li>
<li><input type="hidden" value="隐藏的数据">：隐藏域</li>
<li><input type="radio">：输入框</li>
<li>注意：如果单选按钮要真正做到单选的效果，需要进行分组。通过name属性，可以将多个单选按钮设置为一组</li>
<li>默认选中 checked=”checked”</li>
<li><input type="checkbox" checked="checked" name="hobby">：复选框</li>
<li><input type="button" value="按钮上的文字">：设置一个普通按钮</li>
<li><input type="image" value="图像的路径">：设置一个图像按钮（图像域），按钮的图片需要通过src来进行设置</li>
<li><input type="submit">：提交按钮</li>
<li><input type="reset">：重置按钮</li>
<li>注意：不管是提交还是重置，都要先有一个表单<form></form></li>
<li>下拉框</li>
<li>文本域</li>
</ul>
<p>注意：1. reset如果不设置value值，会有默认值<br>        2.reset、submit等需要和form标签配合使用，否则不会有效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML基础知识（2）]]></title>
      <url>https://mango-mao.github.io/mangomao/2014/12/14/HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="html中的空格合并"><a href="#html中的空格合并" class="headerlink" title="html中的空格合并"></a>html中的空格合并</h4><ul>
<li>空格合并：在html源代码里面写的空格，换行，tab，浏览器解析的时候不敏感，再多的连续的空格，换行，tab浏览器只会解析成一个空格。</li>
</ul>
<ul>
<li>如果想要多个空格，使用特殊字符——字符实体<ul>
<li><code> </code>一个中文字符的位置</li>
<li><code>&lt;</code> &lt;</li>
<li><code>&gt;</code> &gt;</li>
<li><code>&amp;</code> &amp;符号</li>
<li><code>©</code> 版权</li>
<li><code>®</code> 商标</li>
</ul>
</li>
</ul>
<p><a id="more"></a>  ​</p>
<h4 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h4><ul>
<li>一行可以放多个标签，span标签的大小由内容决定</li>
</ul>
<h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><ul>
<li>一个div标签会占一行的位置，高度是由内容决定的，宽度就是一整行</li>
</ul>
<h4 id="三层分离"><a href="#三层分离" class="headerlink" title="三层分离"></a>三层分离</h4><ul>
<li>html结构层</li>
<li>css样式层</li>
<li>javascript行为层</li>
</ul>
<h4 id="html语义化的好处"><a href="#html语义化的好处" class="headerlink" title="html语义化的好处"></a>html语义化的好处</h4><ul>
<li>SEO优化</li>
<li>让我们自己编写代码的时候会更加的清晰</li>
</ul>
<h4 id="CSS的初体验"><a href="#CSS的初体验" class="headerlink" title="CSS的初体验"></a>CSS的初体验</h4><ul>
<li>css代码写在style标签里，style标签放在head标签里面，title标签后面</li>
</ul>
<h4 id="字体相关的属性"><a href="#字体相关的属性" class="headerlink" title="字体相关的属性"></a>字体相关的属性</h4><ul>
<li>浏览器默认宋体</li>
<li>font-size：设置字体的大小</li>
<li>font-weight：设置字体的粗细。设置数值（100-900，只可以用整数，以每个字体类型为标准）或者关键词</li>
<li>font-family：设置字体</li>
<li>font-style：设置斜体</li>
</ul>
<h4 id="font"><a href="#font" class="headerlink" title="font"></a>font</h4><ul>
<li>font连写：font-style font-weight font-size font-family</li>
<li>一次性font属性可以设置多个css效果。像这种一次可以设置多个效果的属性叫做复合属性</li>
</ul>
<h4 id="颜色表示方式"><a href="#颜色表示方式" class="headerlink" title="颜色表示方式"></a>颜色表示方式</h4><ul>
<li><p>使用颜色的单词来设置颜色</p>
</li>
<li><p>十六进制</p>
</li>
<li><p>RGB<br>​</p>
</li>
</ul>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul>
<li>选择器的作用：选择html的内容，为其设置css</li>
</ul>
<ul>
<li><p>标签选择器：直接在选择器的部分写上标签名，此时，当前页面的该标签都会被选中来设置css</p>
</li>
<li><p>类选择器的使用方式</p>
<ul>
<li>给标签设置class=类名</li>
<li>设置类选择器样式</li>
</ul>
</li>
<li><p>id选择器的使用方式</p>
<ul>
<li>给标签设置id=id名</li>
<li>设置id选择器的样式</li>
</ul>
<p>注意：元素的id是唯一的</p>
<p>id不是给css用的，而是JavaScript</p>
</li>
<li><p>命名规范</p>
<ul>
<li>取名的时候可以使用的字符：0-9，a-z，A-Z，_，-</li>
<li>取名的时候不能用数字开头</li>
<li>潜规则：这个类选择器是干什么用的就取什么名字</li>
</ul>
</li>
<li><p>通配符选择器的使用方式</p>
<ul>
<li>*</li>
<li>作用：选择页面中所有的标签去设置一些统一的样式</li>
<li>效率比较低，不建议使用</li>
</ul>
</li>
<li><p>并集选择器 </p>
<ul>
<li>同时选择多个内容设置同一个样式</li>
<li>如果需要设置一些统一的样式，用并集选择器</li>
</ul>
</li>
<li><p>交集选择器</p>
</li>
<li><p>后代选择器：选中某些元素下面的符合条件的其它元素，不管是直接子元素还是非直接子元素，都会选中</p>
<ul>
<li>div p 选择了div标签下面的p标签</li>
</ul>
</li>
<li><p>子代选择器：选中某些元素下面的符合条件的其它元素，但必须是直接子元素  &gt;</p>
</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>注释不可以嵌套</li>
</ul>
<h4 id="添加CSS的三种方式"><a href="#添加CSS的三种方式" class="headerlink" title="添加CSS的三种方式"></a>添加CSS的三种方式</h4><ul>
<li><p>嵌套样式</p>
</li>
<li><p>行内样式：把css写在style属性里</p>
<ul>
<li>多个样式之间用分号隔开</li>
</ul>
</li>
<li><p>外联样式：把css写在另外一个文件里</p>
<p>注意：中文的空格占两个字母的空间（全角）</p>
</li>
</ul>
<h4 id="三种样式的使用场景"><a href="#三种样式的使用场景" class="headerlink" title="三种样式的使用场景"></a>三种样式的使用场景</h4><ul>
<li>行内：单独给一个标签设置样式的时候，不经常使用</li>
<li>嵌套：设置的样式只给当前的网页使用，假如你编写的样式只有当前页面会使用到，那么请使用嵌套样式</li>
<li>外联：设置的样式可以给多个网页使用，假如你写的样式在多个页面都会被使用到，就使用外联样式</li>
</ul>
<h4 id="text相关三个属性"><a href="#text相关三个属性" class="headerlink" title="text相关三个属性"></a>text相关三个属性</h4><ul>
<li>text-indent：文本的首行缩进<ul>
<li>em：单位，1个em相当于一个文字的大小</li>
</ul>
</li>
<li>text-align：文本的对齐方式（right，center，left）</li>
<li>text-decoration： 设置文本的装饰线</li>
<li>margin：0 auto <ul>
<li>作用：使容器在页面里居中显示</li>
</ul>
</li>
</ul>
<h4 id="css三大特性"><a href="#css三大特性" class="headerlink" title="css三大特性"></a>css三大特性</h4><ul>
<li><p>继承性    </p>
<ul>
<li><p>父元素的css属性可以被子元素继承使用</p>
</li>
<li><p>注意：可以继承的css属性：text-，font-，line-开头的属性都可以继承，color</p>
</li>
<li><p>使用场景：通过body给整个网页设置一个通用的font-</p>
</li>
<li><p>特殊性</p>
<ul>
<li><p>如果是一个a标签，它是不能从父元素继承字体的颜色，因为a标签有自己的默认颜色蓝色，如果要改变a标签的字体颜色，请选择这个a标签，再改color</p>
</li>
<li><p>如果是一个标题标签，它是不能从父元素继承字体的大小的，因为标题标签有自己默认的字体大小，要改变字体大小，请直接选中标题标签设置font-size</p>
<p>​:flower:​ 总结：标签如果有默认的样式的时候，继承过来的css属性就不能起作用</p>
</li>
<li><p>div如果没有设置高度的时候，而且也没有内容，那么它的高度为0，宽度默认继承父元素的宽度</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>层叠性</p>
<ul>
<li>设置相同的css属性的时候，根据远近亲疏让最“亲”的css属性起作用，其它的被覆盖</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li>！important》行内样式》id选择器》类选择器》标签选择器》通配符选择器》继承</li>
<li>虽然！important是一个变数，但是无法继承</li>
</ul>
</li>
<li><p>权重</p>
<ul>
<li>当组合选择器进行使用的时候，我们有一个计算优先级的公式（权重的计算）</li>
<li>（！important的数量，id选择器的数量，类选择器的数量，标签选择器的数量）</li>
<li>浏览器对父元素不敏感</li>
</ul>
<p>​</p>
</li>
</ul>
<h4 id="背景相关的几个属性"><a href="#背景相关的几个属性" class="headerlink" title="背景相关的几个属性"></a>背景相关的几个属性</h4><ul>
<li>背景颜色：background-color</li>
<li>背景图片：background-image</li>
<li>背景是否重复：background-repeat。值有no-repeat/repeat-x/repeat-y/repeat（默认）</li>
<li>背景图片的位置：background-position：center center；水平方向的值：right center  left；垂直方向的值：top center bottom</li>
<li>背景的复合属性：background</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>*{margin：0；padding：0；}</li>
<li>出现图片错位的原因：father的宽度继承自body，会跟着浏览器的窗口变化，son的宽度设定为1000px，当窗口拉动导致father的宽度小于1000的时候，father父元素无法完整显示son了，于是出现了错位的请问</li>
<li>解决方案：给father设置一个最小的宽度：min-width：1000px</li>
<li>背景设置一般图片多大元素宽高就设置多大</li>
</ul>
<h4 id="元素的显示方式"><a href="#元素的显示方式" class="headerlink" title="元素的显示方式"></a>元素的显示方式</h4><ul>
<li>行内元素<ul>
<li>一行里面可以显示多个</li>
<li>无法设置宽高</li>
<li>大小由内容决定</li>
</ul>
</li>
<li>块级元素<ul>
<li>独占一行</li>
<li>可以设置宽高</li>
<li>默认宽度一整行</li>
</ul>
</li>
<li>行内块级元素<ul>
<li>可以设置宽高</li>
<li>一行里面可以显示多个</li>
</ul>
</li>
<li>设置垂直居中：line-height：容器的高度</li>
</ul>
<h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><ul>
<li>a：link——给a标签设置没有被访问过的样式</li>
<li>a：visited——给a标签设置访问过的样式</li>
<li>a：hover——给a标签设置鼠标悬停时的样式</li>
<li>a：active——设置a标签被激活时的样式（被点击时的样式）</li>
<li>要按照一定的顺序编写，否则样式有可能会无法显示</li>
<li>有些锚伪类除了可以作用于a标签上还可以作用在其它标签上<ul>
<li>：link——只能用于a标签</li>
<li>：visited——只能用于a标签</li>
<li>：hover——其它标签也可以使用这个伪类</li>
<li>：active——其它标签也可以使用这个伪类</li>
</ul>
</li>
</ul>
<h4 id="行高（line-height"><a href="#行高（line-height" class="headerlink" title="行高（line-height)"></a>行高（line-height)</h4><ul>
<li>应用：如果行高等于容器的高度，那么元素在父元素中垂直居中</li>
<li>行高的定义：两行文本之间基线的距离就叫做行高</li>
</ul>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ul>
<li>在写一个html页面的时候，其实就相当于在HTML页面叠盒子</li>
<li>万物皆盒子</li>
<li>border<ul>
<li>border-color： 边框的颜色</li>
<li>border-width：边框的宽度</li>
<li>border-style：边框的样式</li>
<li>border-top：设置上边框的粗细样式颜色</li>
<li>border-right：</li>
<li>border-bottom:</li>
<li>border-left:</li>
</ul>
</li>
<li>所有跟外观相关的设置，请不要再使用html来设置了，请使用css来设置，这就是三层分离</li>
<li>border-collapse：设置表格的一个css属性，作用：去除表格中的单元格的间隙</li>
<li>padding：设置内边距的css属性。所谓内容距就是内容与边框之间的距离<ul>
<li>padding：40px——设置内容与边框中间的距离是40px，上右下左四个方向都是40px的距离</li>
<li>padding：40px 80px——设置上内边距，下内边距为40px，左内边距，右内边距是80px</li>
<li>padding：40px 60px 80px——设置上内边距40px，左右内边距的距离是60px，下内边距是80px</li>
<li>padding：40px 60px 80px 100px——以顺时针方向进行设置</li>
</ul>
</li>
<li>​:kiss: padding会改变盒子的大小（跟日常生活中有区别）</li>
<li>计算盒子大小的公式：<ul>
<li>盒子宽：border-left-width+padding-left+width+padding-right+border-right-width</li>
<li>盒子高：border-top-width+padding-top+height+padding-bottom+border-bottom-width</li>
</ul>
</li>
<li>特殊情况下padding不会改变盒子的大小<ul>
<li>当一个大盒子包含一个小盒子，并且大小盒子都是块级元素，而且小盒子的宽度是继承自大盒子的话，那么设置小盒子的padding-left，padding-right不会改变小盒子的大小</li>
</ul>
</li>
<li>margin：设置盒子与盒子之间的距离，外边距</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>body默认带有margin： 8px的属性</li>
<li>p标签带有margin：font-size 0；</li>
<li>h标签默认带有margin-top和margin-bottom</li>
<li>ul标签带有上下的margin以及padding-left</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML&CSS基础知识（1）]]></title>
      <url>https://mango-mao.github.io/mangomao/2014/12/13/HMTL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="浏览器与服务器之间的交互过程"><a href="#浏览器与服务器之间的交互过程" class="headerlink" title="浏览器与服务器之间的交互过程"></a>浏览器与服务器之间的交互过程</h5><ol>
<li><p>用户在浏览器的地址栏中输入网站的地址</p>
</li>
<li><p>浏览器将请求报文发送给地址栏中网站的服务器</p>
</li>
<li><p>服务器根据请求报文返回页面数据给浏览器</p>
</li>
<li><p>浏览器得到响应的数据以后将之呈现给用户</p>
</li>
</ol>
<p><a id="more"></a>  ​</p>
<h5 id="请求报文和响应报文——审查元素-》network"><a href="#请求报文和响应报文——审查元素-》network" class="headerlink" title="请求报文和响应报文——审查元素 》network"></a>请求报文和响应报文——审查元素 》network</h5><ol>
<li><p>请求报文：浏览器发送给服务器的</p>
</li>
<li><p>响应报文：服务器返回给浏览器的</p>
</li>
</ol>
<h5 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h5><ul>
<li>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。</li>
<li>浏览器内核（Rendering Engine）：负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>IE：trident；  Safari：webkit；Firefox：gecko；chrome、Opera：blink</li>
</ul>
<h5 id="文件的后缀名"><a href="#文件的后缀名" class="headerlink" title="文件的后缀名"></a>文件的后缀名</h5><ul>
<li>修改文件的后缀名是不会改变内容，只决定打开方式</li>
<li>H系列标签作用：把页面上的文字加上标题的语义</li>
</ul>
<h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul>
<li>http协议<ul>
<li>请求报文</li>
<li>响应报文</li>
<li>URL：协议名、服务器的IP地址、端口号、请求文件的名称</li>
</ul>
</li>
<li>浏览器接受用户操作——浏览器封装HTTP请求——链接服务器：DNS解析——发送请求Request——服务器接收请求——处理请求——返回响应报文——浏览器接收响应报文——渲染页面呈现</li>
<li>如果没有设置端口号那么默认的端口是：80</li>
</ul>
<p>图片是另外请求</p>
<p>继续渲染与请求服务器的图片</p>
<h5 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h5><ul>
<li>img：图片标签</li>
<li>src：标签的属性，设置图片的路径</li>
<li>Alt：如果图片不存在，设置图片的文本信息</li>
<li>title：设置图片的提示信息，当鼠标悬停在图片上方的时候，就会显示提示信息</li>
</ul>
<h5 id="访问有图片的网页时，浏览器和服务器的交互过程"><a href="#访问有图片的网页时，浏览器和服务器的交互过程" class="headerlink" title="访问有图片的网页时，浏览器和服务器的交互过程"></a>访问有图片的网页时，浏览器和服务器的交互过程</h5><ul>
<li>用户在地址栏中输入一个网页的网址，按回车</li>
<li>浏览器就会向这个地址的服务器发送一个请求报文</li>
<li>服务器根据请求报文返回网页的页面数据给浏览器</li>
<li>浏览器解析返回的响应报文，并渲染显示</li>
<li>当浏览器解析到图片的时候，它不知道图片是在哪里的，所以，浏览器会再发送一次请求报文，去请求服务器的那一张图片</li>
<li>然后等待服务器返回图片的响应的时候，浏览器还会继续解析下面的其它内容</li>
</ul>
<h5 id="路径分为两种情况"><a href="#路径分为两种情况" class="headerlink" title="路径分为两种情况"></a>路径分为两种情况</h5><ul>
<li>绝对路径：从盘符开始寻找路径</li>
<li>相对路径：从当前页面开始寻找路径</li>
</ul>
<h5 id="a标签使用的地方"><a href="#a标签使用的地方" class="headerlink" title="a标签使用的地方"></a>a标签使用的地方</h5><ul>
<li>空连接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></li>
<li>去到其它的网页：<code>&lt;a href=&quot;其它的网页.html&quot;&gt;</code></li>
<li>去到其它页面的某一个地方，在跳转的页面进行定位 <code>&lt;a href=&quot;其它的网页.html#id&quot;&gt;</code></li>
<li>去到本页面的某一个地方：<code>&lt;a href=&quot;#id&quot;&gt;</code></li>
<li>下载（不建议）</li>
</ul>
<h5 id="a标签的属性target"><a href="#a标签的属性target" class="headerlink" title="a标签的属性target"></a>a标签的属性target</h5><ul>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_blank&quot;&gt;将会用新的页面打开1.html&lt;/a&gt;</code></li>
<li><code>&lt;a href=&quot;1.html&quot; target=&quot;_self&quot;&gt;将会在当前的页面打开1.html&lt;/a&gt;</code></li>
<li>base 为页面上所有a标签设置跳转的方式（base标签一般放在title下面，写在head里面）<code>&lt;base target=&quot;_blank&quot;&gt;</code></li>
</ul>
<h5 id="DOCTYPE文档类型"><a href="#DOCTYPE文档类型" class="headerlink" title="DOCTYPE文档类型"></a>DOCTYPE文档类型</h5><ul>
<li>DTD 文档类型定义</li>
<li>html和XHTML规范<ul>
<li>html：3种<ul>
<li>strict</li>
<li>transitional（用的最多）</li>
<li>frameset</li>
</ul>
</li>
<li>XHTML：3种</li>
</ul>
</li>
<li>lang 用来设置当前页面的语言<ul>
<li>设置页面上主要使用语言的类型</li>
<li>将来做SEO的时候在权重上起到一定的作用</li>
<li>用于特殊设备上的设置，eg，盲人设备</li>
</ul>
</li>
</ul>
<h5 id="关于SEO"><a href="#关于SEO" class="headerlink" title="关于SEO"></a>关于SEO</h5><ul>
<li>搜索引擎优化（网站在搜索页面上的排名靠前）<ul>
<li>买排名，不靠谱</li>
<li>将页面做成静态页面（html）</li>
<li>发外链</li>
<li>页面的友好性（规范）：在合适的地方使用合适的标签，合理的使用标签的语义化</li>
</ul>
</li>
<li>讨好搜索引擎<ul>
<li>网络爬虫，搜索引擎机器人：收录Internet上的网站，找到访问量高的，语义化好的网站，最后将这些网站作为搜索的结果呈现给用户观看  任务：就是用来访问页面给页面排序，从而在用户搜索的时候可以有一个先后的排名</li>
</ul>
</li>
<li><p>让网站更靠前的方式：</p>
<ul>
<li>买排名，不靠谱</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h5><ul>
<li>作用：让页面拥有一个属于自己的标题</li>
<li>title中的文本在SEO中占有很大的权重</li>
<li>h1,h2</li>
</ul>
<h5 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h5><ul>
<li>注意：meta中设置的所有的内容在页面都不会显示，</li>
</ul>
<ul>
<li><p>description 可以描述页面，可以用来使用百度程序（网络爬虫）来收录关键信息，以此提高页面的排名</p>
</li>
<li><p>keywords  关键词，可以用来提高页面的关键词的比重的一种方式，:angry:英文的逗号</p>
</li>
<li><p>最多不要超过十个</p>
</li>
<li><p>charset</p>
<ul>
<li><p>字符集：相当于一个字库，在这个字库有很多的文字，每一个文字都有对应的编码</p>
</li>
<li><p>当你设置的网页的编码格式和保存的编码格式不一样的时候，就会发生乱码</p>
</li>
<li><p>gb2312：国际标准，收录了汉字，片假名</p>
</li>
<li><p>gbk：国标扩（扩展版），一个文字2个字节</p>
</li>
<li><p>UTF-8：收录全世界所有的语言中的文字，一个文字3个字节</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul>
<li>无序列表<ul>
<li>ul标签的作用：表示在这里有一个无序的列表</li>
<li>li标签的作用：表示列表的项</li>
<li>注意：ul不能单独出现，ul里面一定要放li，li是一个容器，放什么其他的标签都可以</li>
</ul>
</li>
<li>有序列表<ul>
<li>作用：显示一段有顺序的数据</li>
<li>语义：一组有顺序的数据</li>
</ul>
</li>
<li>自定义列表：dl,dt,dd<ul>
<li>dl标签：写一个自定义列表</li>
<li>dt标签：它代表的就是这儿有一个自定义的列表项</li>
<li>dd标签：代表dt对应的列表项中的具体内容</li>
</ul>
</li>
</ul>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><ul>
<li><p>table标签：表示是一个表格的内容</p>
</li>
<li><p>tr标签：表示是表格中的一行</p>
</li>
<li><p>td标签：表示是表格中的一个单元格</p>
</li>
<li><p>表格的其它标签和属性：</p>
<ul>
<li>表格的属性：<table border="1" cellspacing="" cellpadding=""> <ul>
<li>border：设置表格的边框的宽度 </li>
<li>cellspacing：设置的是表格中的单元格之间的距离</li>
<li>cellpadding：设置的是单元格中的内容与单元格之间的距离</li>
<li>width</li>
<li>height</li>
</ul>
</table></li>
</ul>
</li>
<li><p>表格中的其他标签</p>
<ul>
<li>th标签：设置表头，具体表现的效果是文字加粗，居中</li>
<li>caption标签：设置标题的标题，注意，caption标签应该放在table标签后面</li>
<li>thead标签：设置的是表格的头部信息，一般th的内容都应该放在这里</li>
<li>tbody标签：设置的是表格的主题内容，一般td的内容都放在这里</li>
<li>tfoot标签：设置的是表格的尾部信息，一般是放一些总结性的信息</li>
</ul>
<p>​</p>
</li>
</ul>
<h5 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h5><ul>
<li><code>&lt;input type=&quot;hidden&quot; value=&quot;&quot;&gt;</code> 学习ajax时候用到</li>
<li><input type="text" value="默认值">：输入框</li>
<li><input type="password">：密码框</li>
<li><input type="hidden" value="隐藏的数据">：隐藏域</li>
<li><input type="radio">：输入框</li>
<li>注意：如果单选按钮要真正做到单选的效果，需要进行分组。通过name属性，可以将多个单选按钮设置为一组</li>
<li>默认选中 checked=”checked”</li>
<li><input type="checkbox" checked="checked" name="hobby">：复选框</li>
<li><input type="button" value="按钮上的文字">：设置一个普通按钮</li>
<li><input type="image" value="图像的路径">：设置一个图像按钮（图像域），按钮的图片需要通过src来进行设置</li>
<li><input type="submit">：提交按钮</li>
<li><input type="reset">：重置按钮</li>
<li>注意：不管是提交还是重置，都要先有一个表单<form></form></li>
<li>下拉框</li>
<li>文本域</li>
</ul>
<p>注意：1. reset如果不设置value值，会有默认值<br>        2.reset、submit等需要和form标签配合使用，否则不会有效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap基础知识]]></title>
      <url>https://mango-mao.github.io/mangomao/2014/02/17/Bootstrap%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发当中，一套页面能响应多种终端并且在各种终端下显示的布局和内容不一样而且展示的比较合理，或者说一个网站能适配多种屏幕尺寸类型的网站。这样的一个开发模式就是响应式。<br>我们一般用bootstrap来帮助我们完成响应式建站。</p>
<a id="more"></a>
<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><p>在响应式开发当中我们使用的是媒体查询中的screen查询浏览器的宽度来定义不同宽度区间的样式和布局。<br>代码：</p>
<pre><code>@media screen and (min-width: 768px){}
@media screen and (min-width: 992px){}
@media screen and (min-width: 1200px){}
</code></pre><p>也可以:</p>
<pre><code>@media (max-width: 767px){}
@media (min-width: 768px) and (max-width: 991px){}
@media (min-width: 992px) and (max-width: 1199px){}
@media (min-width: 1200px){}
</code></pre><p>媒体查询可以指定查询的属性screen也可以不指定默认回去查询屏幕。<br>可以使用css覆盖的原理，也可以定义区间范围，可以多条件查询。</p>
<h1 id="Bootstrap常用样式"><a href="#Bootstrap常用样式" class="headerlink" title="Bootstrap常用样式"></a>Bootstrap常用样式</h1><h2 id="container类"><a href="#container类" class="headerlink" title="container类"></a>container类</h2><p>用于定义一个固定宽度且居中的版心 </p>
<h2 id="row类"><a href="#row类" class="headerlink" title="row类"></a>row类</h2><p>因为每一个列默认有一个15px的左右外边距，row类的一个作用就是通过左右-15px屏蔽掉这个边距<br>col-<em>*-</em>类 </p>
<ul>
<li>col-xs-[列数]：在超小屏幕下展示几份 </li>
<li>col-sm-[列数]：在小屏幕下展示几份 </li>
<li><p>col-md-[列数]：在中等屏幕下展示几份 </p>
</li>
<li><p>col-lg-[列数]：在大屏幕下展示几份<br>xs : 超小屏幕 手机 (&lt;768px)<br>sm : 小屏幕 平板 (≥768px)<br>md : 中等屏幕 桌面显示器 (≥992px)<br>lg : 大屏幕 大桌面显示器 (≥1200px)</p>
</li>
</ul>
<h2 id="hidden-类-在不同的屏幕下隐藏。"><a href="#hidden-类-在不同的屏幕下隐藏。" class="headerlink" title="hidden 类 在不同的屏幕下隐藏。"></a>hidden 类 在不同的屏幕下隐藏。</h2><ul>
<li>hidden-xs</li>
<li>hidden-sm</li>
<li>hidden-md</li>
<li>hidden-lg</li>
</ul>
<h2 id="text-类"><a href="#text-类" class="headerlink" title="text-* 类"></a>text-* 类</h2><ul>
<li>text-center 文本居中</li>
<li>text-left 文本左对齐</li>
<li>text-right 文本右对齐</li>
</ul>
<h2 id="pull-类"><a href="#pull-类" class="headerlink" title="pull-* 类"></a>pull-* 类</h2><ul>
<li>pull-left 左浮动类</li>
<li>pull-right 右浮动类</li>
</ul>
<h2 id="center-block-类"><a href="#center-block-类" class="headerlink" title="center-block 类"></a>center-block 类</h2><p>让一个固定宽度的元素居中。</p>
<h1 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h1><p>这些属性都是提供给屏幕阅读器的，我们可以忽略。</p>
<ul>
<li>role</li>
<li>aria-*</li>
<li>class=”sr-only”</li>
</ul>
<p>指定插件类型，和被控制的目标元素</p>
<ul>
<li>data-toggle</li>
<li>data-target</li>
</ul>
<p>a标签也可以通过href来指定被控制的目标元素</p>
]]></content>
    </entry>
    
  
  
</search>
